[
  {
    "code": "function render(name, options, callback) {\n  var cache = this.cache;\n  var done = callback;\n  var engines = this.engines;\n  var opts = options;\n  var view;\n\n  // support callback function as second arg\n  if (typeof options === 'function') {\n    done = options;\n    opts = {}",
    "comment": "* Render the given view `name` name with `options`\n * and a callback accepting an error and the\n * rendered template string.\n *\n * Example:\n *\n *    app.render('email', { name: 'Tobi' }, function(err, html){\n *      // ...\n *    })\n *\n * @param {String} name\n * @param {Object|Function} options or fn\n * @param {Function} callback\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.9,
    "comment_type": "jsdoc"
  },
  {
    "code": "function append(field, val) {\n  var prev = this.get(field);\n  var value = val;\n\n  if (prev) {\n    // concat the new and prev vals\n    value = Array.isArray(prev) ? prev.concat(val)\n      : Array.isArray(val) ? [prev].concat(val)\n        : [prev, val]\n  }",
    "comment": "* Append additional header `field` with value `val`.\n *\n * Example:\n *\n *    res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>']);\n *    res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly');\n *    res.append('Warning', '199 Miscellaneous warning');\n *\n * @param {String} field\n * @param {String|Array} val\n * @return {ServerResponse} for chaining\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/response.js",
    "quality_score": 0.9,
    "comment_type": "jsdoc"
  },
  {
    "code": "function command(settings) {\n  var options = settings.execOptions;\n  var executable = options.exec;\n  var args = [];\n\n  // after \"executable\" go the exec args (like --debug, etc)\n  if (options.execArgs) {\n    [].push.apply(args, options.execArgs);\n  }",
    "comment": "* command constructs the executable command to run in a shell including the\n * user script, the command arguments.\n *\n * @param  {Object} settings Object as:\n *                           { execOptions: {\n *                               exec: String,\n *                               [script: String],\n *                               [scriptPosition: Number],\n *                               [execArgs: Array<string>]\n *                             }\n *                           }\n * @return {Object}          an object with the node executable and the\n *                           arguments to the command",
    "language": "javascript",
    "repo": "remy/nodemon",
    "file_path": "lib/config/command.js",
    "quality_score": 0.9,
    "comment_type": "jsdoc"
  },
  {
    "code": "function hillCipherEncrypt(message, keyString) {\n  // The keyString and message can only contain letters.\n  const onlyLettersRegExp = /^[a-zA-Z]+$/;\n  if (!onlyLettersRegExp.test(message) || !onlyLettersRegExp.test(keyString)) {\n    throw new Error('The message and key string can only contain letters');\n  }",
    "comment": "* Encrypts the given message using Hill Cipher.\n *\n * @param {string} message plaintext\n * @param {string} keyString\n * @return {string} cipherString",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/cryptography/hill-cipher/hillCipher.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function onEachRail(rail, currentRail) {\n    return currentRail === targetRailIndex\n      ? [...rail, letter]\n      : rail;\n  }",
    "comment": "* Given a rail, adds a char to it if it matches a targetIndex.\n   *\n   * @param {Rail} rail\n   * @param {number} currentRail\n   * @returns {Rail}",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/cryptography/rail-fence-cipher/railFenceCipher.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function eulerianPath(graph) {\n  const eulerianPathVertices = [];\n\n  // Set that contains all vertices with even rank (number of neighbors).\n  const evenRankVertices = {}",
    "comment": "* Fleury's algorithm of finding Eulerian Path (visit all graph edges exactly once).\n *\n * @param {Graph} graph\n * @return {GraphVertex[]}",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/graph/eulerian-path/eulerianPath.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function setProxy(options, configProxy, location) {\n  let proxy = configProxy;\n  if (!proxy && proxy !== false) {\n    const proxyUrl = proxyFromEnv.getProxyForUrl(location);\n    if (proxyUrl) {\n      proxy = new URL(proxyUrl);\n    }",
    "comment": "* If the proxy or config afterRedirects functions are defined, call them with the options\n *\n * @param {http.ClientRequestArgs} options\n * @param {AxiosProxyConfig} configProxy configuration from Axios options object\n * @param {string} location\n *\n * @returns {http.ClientRequestArgs}",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/adapters/http.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createInstance(defaultConfig) {\n  const context = new Axios(defaultConfig);\n  const instance = bind(Axios.prototype.request, context);\n\n  // Copy axios.prototype to instance\n  utils.extend(instance, Axios.prototype, context, {allOwnKeys: true}",
    "comment": "* Create an instance of Axios\n *\n * @param {Object} defaultConfig The default config for the instance\n *\n * @returns {Axios} A new instance of Axios",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/axios.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "class CancelToken {\n  constructor(executor) {\n    if (typeof executor !== 'function') {\n      throw new TypeError('executor must be a function.');\n    }",
    "comment": "* A `CancelToken` is an object that can be used to request cancellation of an operation.\n *\n * @param {Function} executor The executor function.\n *\n * @returns {CancelToken}",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/cancel/CancelToken.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function CanceledError(message, config, request) {\n  // eslint-disable-next-line no-eq-null,eqeqeq\n  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);\n  this.name = 'CanceledError';\n}",
    "comment": "* A `CanceledError` is an object that is thrown when an operation is canceled.\n *\n * @param {string=} message The message.\n * @param {Object=} config The config.\n * @param {Object=} request The request.\n *\n * @returns {CanceledError} The created error.",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/cancel/CanceledError.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function AxiosError(message, code, config, request, response) {\n  Error.call(this);\n\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n  }",
    "comment": "* Create an Error with the specified message, config, error code, request and response.\n *\n * @param {string} message The error message.\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\n * @param {Object} [config] The config.\n * @param {Object} [request] The request.\n * @param {Object} [response] The response.\n *\n * @returns {Error} The created error.",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/core/AxiosError.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function dispatchRequest(config) {\n  throwIfCancellationRequested(config);\n\n  config.headers = AxiosHeaders.from(config.headers);\n\n  // Transform request data\n  config.data = transformData.call(\n    config,\n    config.transformRequest\n  );\n\n  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {\n    config.headers.setContentType('application/x-www-form-urlencoded', false);\n  }",
    "comment": "* Dispatch a request to the server using the configured adapter.\n *\n * @param {object} config The config that is to be used for the request\n *\n * @returns {Promise} The Promise to be fulfilled",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/core/dispatchRequest.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function settle(resolve, reject, response) {\n  const validateStatus = response.config.validateStatus;\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\n    resolve(response);\n  }",
    "comment": "* Resolve or reject a Promise based on response status.\n *\n * @param {Function} resolve A function that resolves the promise.\n * @param {Function} reject A function that rejects the promise.\n * @param {object} response The response.\n *\n * @returns {object} The response.",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/core/settle.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function transformData(fns, response) {\n  const config = this || defaults;\n  const context = response || config;\n  const headers = AxiosHeaders.from(context.headers);\n  let data = context.data;\n\n  utils.forEach(fns, function transform(fn) {\n    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);\n  }",
    "comment": "* Transform the data for a request or a response\n *\n * @param {Array|Function} fns A single function or Array of functions\n * @param {?Object} response The response object\n *\n * @returns {*} The resulting transformed data",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/core/transformData.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function calculateRank({\n  all_commits,\n  commits,\n  prs,\n  issues,\n  reviews,\n  // eslint-disable-next-line no-unused-vars\n  repos, // unused\n  stars,\n  followers,\n}) {\n  const COMMITS_MEDIAN = all_commits ? 1000 : 250,\n    COMMITS_WEIGHT = 2;\n  const PRS_MEDIAN = 50,\n    PRS_WEIGHT = 3;\n  const ISSUES_MEDIAN = 25,\n    ISSUES_WEIGHT = 1;\n  const REVIEWS_MEDIAN = 2,\n    REVIEWS_WEIGHT = 1;\n  const STARS_MEDIAN = 50,\n    STARS_WEIGHT = 4;\n  const FOLLOWERS_MEDIAN = 10,\n    FOLLOWERS_WEIGHT = 1;\n\n  const TOTAL_WEIGHT =\n    COMMITS_WEIGHT +\n    PRS_WEIGHT +\n    ISSUES_WEIGHT +\n    REVIEWS_WEIGHT +\n    STARS_WEIGHT +\n    FOLLOWERS_WEIGHT;\n\n  const THRESHOLDS = [1, 12.5, 25, 37.5, 50, 62.5, 75, 87.5, 100];\n  const LEVELS = [\"S\", \"A+\", \"A\", \"A-\", \"B+\", \"B\", \"B-\", \"C+\", \"C\"];\n\n  const rank =\n    1 -\n    (COMMITS_WEIGHT * exponential_cdf(commits / COMMITS_MEDIAN) +\n      PRS_WEIGHT * exponential_cdf(prs / PRS_MEDIAN) +\n      ISSUES_WEIGHT * exponential_cdf(issues / ISSUES_MEDIAN) +\n      REVIEWS_WEIGHT * exponential_cdf(reviews / REVIEWS_MEDIAN) +\n      STARS_WEIGHT * log_normal_cdf(stars / STARS_MEDIAN) +\n      FOLLOWERS_WEIGHT * log_normal_cdf(followers / FOLLOWERS_MEDIAN)) /\n      TOTAL_WEIGHT;\n\n  const level = LEVELS[THRESHOLDS.findIndex((t) => rank * 100 <= t)];\n\n  return { level, percentile: rank * 100 }",
    "comment": "* Calculates the users rank.\n *\n * @param {object} params Parameters on which the user's rank depends.\n * @param {boolean} params.all_commits Whether `include_all_commits` was used.\n * @param {number} params.commits Number of commits.\n * @param {number} params.prs The number of pull requests.\n * @param {number} params.issues The number of issues.\n * @param {number} params.reviews The number of reviews.\n * @param {number} params.repos Total number of repos.\n * @param {number} params.stars The number of stars.\n * @param {number} params.followers The number of followers.\n * @returns {{level: string, percentile: number}}} The users rank.",
    "language": "javascript",
    "repo": "anuraghazra/github-readme-stats",
    "file_path": "src/calculateRank.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function copyFiles(langCode, baseLang) {\n    if (fs.existsSync(\"./languages\")) {\n        fs.rmSync(\"./languages\", {\n            recursive: true,\n            force: true,\n        }",
    "comment": "* Copy across the required language files\n * Creates a local directory (./languages) and copies the required files\n * into it.\n * @param {string} langCode Code of language to update. A file will be\n * created with this code if one does not already exist\n * @param {string} baseLang The second base language file to copy. This\n * will be ignored if set to \"en\" as en.js is copied by default\n * @returns {void}",
    "language": "javascript",
    "repo": "louislam/uptime-kuma",
    "file_path": "extra/update-language-files/index.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "class Controls {\n\n\tconstructor( Reveal ) {\n\n\t\tthis.Reveal = Reveal;\n\n\t\tthis.onNavigateLeftClicked = this.onNavigateLeftClicked.bind( this );\n\t\tthis.onNavigateRightClicked = this.onNavigateRightClicked.bind( this );\n\t\tthis.onNavigateUpClicked = this.onNavigateUpClicked.bind( this );\n\t\tthis.onNavigateDownClicked = this.onNavigateDownClicked.bind( this );\n\t\tthis.onNavigatePrevClicked = this.onNavigatePrevClicked.bind( this );\n\t\tthis.onNavigateNextClicked = this.onNavigateNextClicked.bind( this );\n\t\tthis.onEnterFullscreen = this.onEnterFullscreen.bind( this );\n\n\t}",
    "comment": "* Manages our presentation controls. This includes both\n * the built-in control arrows as well as event monitoring\n * of any elements within the presentation with either of the\n * following helper classes:\n * - .navigate-up\n * - .navigate-right\n * - .navigate-down\n * - .navigate-left\n * - .navigate-next\n * - .navigate-prev\n * - .enter-fullscreen",
    "language": "javascript",
    "repo": "hakimel/reveal.js",
    "file_path": "js/controllers/controls.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "class Fragments {\n\n\tconstructor( Reveal ) {\n\n\t\tthis.Reveal = Reveal;\n\n\t}",
    "comment": "* Handles sorting and navigation of slide fragments.\n * Fragments are elements within a slide that are\n * revealed/animated incrementally.",
    "language": "javascript",
    "repo": "hakimel/reveal.js",
    "file_path": "js/controllers/fragments.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "class Overlay {\n\n\tconstructor( Reveal ) {\n\n\t\tthis.Reveal = Reveal;\n\n\t\tthis.onSlidesClicked = this.onSlidesClicked.bind( this );\n\n\t\tthis.iframeTriggerSelector = null;\n\t\tthis.mediaTriggerSelector = '[data-preview-image], [data-preview-video]';\n\n\t\tthis.stateProps = ['previewIframe', 'previewImage', 'previewVideo', 'previewFit'];\n\t\tthis.state = {}",
    "comment": "* Handles the display of reveal.js' overlay elements used\n * to preview iframes, images & videos.",
    "language": "javascript",
    "repo": "hakimel/reveal.js",
    "file_path": "js/controllers/overlay.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "class Overview {\n\n\tconstructor( Reveal ) {\n\n\t\tthis.Reveal = Reveal;\n\n\t\tthis.active = false;\n\n\t\tthis.onSlideClicked = this.onSlideClicked.bind( this );\n\n\t}",
    "comment": "* Handles all logic related to the overview mode\n * (birds-eye view of all slides).",
    "language": "javascript",
    "repo": "hakimel/reveal.js",
    "file_path": "js/controllers/overview.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function init() {\n  var router = null;\n\n  this.cache = Object.create(null);\n  this.engines = Object.create(null);\n  this.settings = Object.create(null);\n\n  this.defaultConfiguration();\n\n  // Setup getting to lazily add base router\n  Object.defineProperty(this, 'router', {\n    configurable: true,\n    enumerable: true,\n    get: function getrouter() {\n      if (router === null) {\n        router = new Router({\n          caseSensitive: this.enabled('case sensitive routing'),\n          strict: this.enabled('strict routing')\n        }",
    "comment": "* Initialize the server.\n *\n *   - setup default configuration\n *   - setup default middleware\n *   - setup route reflection methods\n *\n * @private",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function handle(req, res, callback) {\n  // final handler\n  var done = callback || finalhandler(req, res, {\n    env: this.get('env'),\n    onerror: logerror.bind(this)\n  }",
    "comment": "* Dispatch a req, res pair into the application. Starts pipeline processing.\n *\n * If no callback is provided, then default error handlers will respond\n * in the event of an error bubbling through the stack.\n *\n * @private",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function use(fn) {\n  var offset = 0;\n  var path = '/';\n\n  // default path to '/'\n  // disambiguate app.use([fn])\n  if (typeof fn !== 'function') {\n    var arg = fn;\n\n    while (Array.isArray(arg) && arg.length !== 0) {\n      arg = arg[0];\n    }",
    "comment": "* Proxy `Router#use()` to add middleware to the app router.\n * See Router#use() documentation for details.\n *\n * If the _fn_ parameter is an express app, then it will be\n * mounted at the _route_ specified.\n *\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function param(name, fn) {\n  if (Array.isArray(name)) {\n    for (var i = 0; i < name.length; i++) {\n      this.param(name[i], fn);\n    }",
    "comment": "* Proxy to `Router#param()` with one added api feature. The _name_ parameter\n * can be an array of names.\n *\n * See the Router#param() docs for more details.\n *\n * @param {String|Array} name\n * @param {Function} fn\n * @return {app} for chaining\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function set(setting, val) {\n  if (arguments.length === 1) {\n    // app.get(setting)\n    return this.settings[setting];\n  }",
    "comment": "* Assign `setting` to `val`, or return `setting`'s value.\n *\n *    app.set('foo', 'bar');\n *    app.set('foo');\n *    // => \"bar\"\n *\n * Mounted servers inherit their parent server's settings.\n *\n * @param {String} setting\n * @param {*} [val]\n * @return {Server} for chaining\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function path() {\n  return this.parent\n    ? this.parent.path() + this.mountpath\n    : '';\n}",
    "comment": "* Return the app's absolute pathname\n * based on the parent(s) that have\n * mounted it.\n *\n * For example if the application was\n * mounted as \"/admin\", which itself\n * was mounted as \"/blog\" then the\n * return value would be \"/blog/admin\".\n *\n * @return {String}\n * @private",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function all(path) {\n  var route = this.route(path);\n  var args = slice.call(arguments, 1);\n\n  for (var i = 0; i < methods.length; i++) {\n    route[methods[i]].apply(route, args);\n  }",
    "comment": "* Special-cased \"all\" method, applying the given route `path`,\n * middleware, and callback to _every_ HTTP method.\n *\n * @param {String} path\n * @param {Function} ...\n * @return {app} for chaining\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function listen() {\n  var server = http.createServer(this)\n  var args = Array.prototype.slice.call(arguments)\n  if (typeof args[args.length - 1] === 'function') {\n    var done = args[args.length - 1] = once(args[args.length - 1])\n    server.once('error', done)\n  }",
    "comment": "* Listen for connections.\n *\n * A node `http.Server` is returned, with this\n * application (which is a `Function`) as its\n * callback. If you wish to create both an HTTP\n * and HTTPS server you may do so with the \"http\"\n * and \"https\" modules as shown here:\n *\n *    var http = require('node:http')\n *      , https = require('node:https')\n *      , express = require('express')\n *      , app = express();\n *\n *    http.createServer(app).listen(80);\n *    https.createServer({ ... }, app).listen(443);\n *\n * @return {http.Server}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function query(){\n  var queryparse = this.app.get('query parser fn');\n\n  if (!queryparse) {\n    // parsing is disabled\n    return Object.create(null);\n  }",
    "comment": "* Parse the query string of `req.url`.\n *\n * This uses the \"query parser\" setting to parse the raw\n * string into an object.\n *\n * @return {String}\n * @api public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function is(types) {\n  var arr = types;\n\n  // support flattened arguments\n  if (!Array.isArray(types)) {\n    arr = new Array(arguments.length);\n    for (var i = 0; i < arr.length; i++) {\n      arr[i] = arguments[i];\n    }",
    "comment": "* Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains the given mime `type`.\n *\n * Examples:\n *\n *      // With Content-Type: text/html; charset=utf-8\n *      req.is('html');\n *      req.is('text/html');\n *      req.is('text/*');\n *      // => true\n *\n *      // When Content-Type is application/json\n *      req.is('json');\n *      req.is('application/json');\n *      req.is('application/*');\n *      // => true\n *\n *      req.is('html');\n *      // => false\n *\n * @param {String|Array} types...\n * @return {String|false|null}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function protocol(){\n  var proto = this.connection.encrypted\n    ? 'https'\n    : 'http';\n  var trust = this.app.get('trust proxy fn');\n\n  if (!trust(this.connection.remoteAddress, 0)) {\n    return proto;\n  }",
    "comment": "* Return the protocol string \"http\" or \"https\"\n * when requested with TLS. When the \"trust proxy\"\n * setting trusts the socket address, the\n * \"X-Forwarded-Proto\" header field will be trusted\n * and used if present.\n *\n * If you're running behind a reverse proxy that\n * supplies https for you this may be enabled.\n *\n * @return {String}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function ips() {\n  var trust = this.app.get('trust proxy fn');\n  var addrs = proxyaddr.all(this, trust);\n\n  // reverse the order (to farthest -> closest)\n  // and remove socket address\n  addrs.reverse().pop()\n\n  return addrs\n}",
    "comment": "* When \"trust proxy\" is set, trusted proxy addresses + client.\n *\n * For example if the value were \"client, proxy1, proxy2\"\n * you would receive the array `[\"client\", \"proxy1\", \"proxy2\"]`\n * where \"proxy2\" is the furthest down-stream and \"proxy1\" and\n * \"proxy2\" were trusted.\n *\n * @return {Array}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function subdomains() {\n  var hostname = this.hostname;\n\n  if (!hostname) return [];\n\n  var offset = this.app.get('subdomain offset');\n  var subdomains = !isIP(hostname)\n    ? hostname.split('.').reverse()\n    : [hostname];\n\n  return subdomains.slice(offset);\n}",
    "comment": "* Return subdomains as an array.\n *\n * Subdomains are the dot-separated parts of the host before the main domain of\n * the app. By default, the domain of the app is assumed to be the last two\n * parts of the host. This can be changed by setting \"subdomain offset\".\n *\n * For example, if the domain is \"tobi.ferrets.example.com\":\n * If \"subdomain offset\" is not set, req.subdomains is `[\"ferrets\", \"tobi\"]`.\n * If \"subdomain offset\" is 3, req.subdomains is `[\"tobi\"]`.\n *\n * @return {Array}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function host(){\n  var trust = this.app.get('trust proxy fn');\n  var val = this.get('X-Forwarded-Host');\n\n  if (!val || !trust(this.connection.remoteAddress, 0)) {\n    val = this.get('Host');\n  }",
    "comment": "* Parse the \"Host\" header field to a host.\n *\n * When the \"trust proxy\" setting trusts the socket\n * address, the \"X-Forwarded-Host\" header field will\n * be trusted.\n *\n * @return {String}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function hostname(){\n  var host = this.host;\n\n  if (!host) return;\n\n  // IPv6 literal support\n  var offset = host[0] === '['\n    ? host.indexOf(']') + 1\n    : 0;\n  var index = host.indexOf(':', offset);\n\n  return index !== -1\n    ? host.substring(0, index)\n    : host;\n}",
    "comment": "* Parse the \"Host\" header field to a hostname.\n *\n * When the \"trust proxy\" setting trusts the socket\n * address, the \"X-Forwarded-Host\" header field will\n * be trusted.\n *\n * @return {String}\n * @api public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function defineGetter(obj, name, getter) {\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable: true,\n    get: getter\n  }",
    "comment": "* Helper function for creating a getter on an object.\n *\n * @param {Object} obj\n * @param {String} name\n * @param {Function} getter\n * @private",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function sendStatus(statusCode) {\n  var body = statuses.message[statusCode] || String(statusCode)\n\n  this.status(statusCode);\n  this.type('txt');\n\n  return this.send(body);\n}",
    "comment": "* Send given HTTP status code.\n *\n * Sets the response status to `statusCode` and the body of the\n * response to the standard description from node's http.STATUS_CODES\n * or the statusCode number if no description.\n *\n * Examples:\n *\n *     res.sendStatus(200);\n *\n * @param {number} statusCode\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/response.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function download (path, filename, options, callback) {\n  var done = callback;\n  var name = filename;\n  var opts = options || null\n\n  // support function as second or third arg\n  if (typeof filename === 'function') {\n    done = filename;\n    name = null;\n    opts = null\n  }",
    "comment": "* Transfer the file at the given `path` as an attachment.\n *\n * Optionally providing an alternate attachment `filename`,\n * and optional callback `callback(err)`. The callback is invoked\n * when the data transfer is complete, or when an error has\n * occurred. Be sure to check `res.headersSent` if you plan to respond.\n *\n * Optionally providing an `options` object to use with `res.sendFile()`.\n * This function will set the `Content-Disposition` header, overriding\n * any `Content-Disposition` header passed as header options in order\n * to set the attachment and filename.\n *\n * This method uses `res.sendFile()`.\n *\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/response.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function contentType(type) {\n  var ct = type.indexOf('/') === -1\n    ? (mime.contentType(type) || 'application/octet-stream')\n    : type;\n\n  return this.set('Content-Type', ct);\n}",
    "comment": "* Set _Content-Type_ response header with `type` through `mime.contentType()`\n * when it does not contain \"/\", or set the Content-Type to `type` otherwise.\n * When no mapping is found though `mime.contentType()`, the type is set to\n * \"application/octet-stream\".\n *\n * Examples:\n *\n *     res.type('.html');\n *     res.type('html');\n *     res.type('json');\n *     res.type('application/json');\n *     res.type('png');\n *\n * @param {String} type\n * @return {ServerResponse} for chaining\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/response.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function header(field, val) {\n  if (arguments.length === 2) {\n    var value = Array.isArray(val)\n      ? val.map(String)\n      : String(val);\n\n    // add charset to content-type\n    if (field.toLowerCase() === 'content-type') {\n      if (Array.isArray(value)) {\n        throw new TypeError('Content-Type cannot be set to an Array');\n      }",
    "comment": "* Set header `field` to `val`, or pass\n * an object of header fields.\n *\n * Examples:\n *\n *    res.set('Foo', ['bar', 'baz']);\n *    res.set('Accept', 'application/json');\n *    res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' });\n *\n * Aliased as `res.header()`.\n *\n * When the set header is \"Content-Type\", the type is expanded to include\n * the charset if not present using `mime.contentType()`.\n *\n * @param {String|Object} field\n * @param {String|Array} val\n * @return {ServerResponse} for chaining\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/response.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function stringify (value, replacer, spaces, escape) {\n  // v8 checks arguments.length for optimizing simple call\n  // https://bugs.chromium.org/p/v8/issues/detail?id=4730\n  var json = replacer || spaces\n    ? JSON.stringify(value, replacer, spaces)\n    : JSON.stringify(value);\n\n  if (escape && typeof json === 'string') {\n    json = json.replace(/[<>&]/g, function (c) {\n      switch (c.charCodeAt(0)) {\n        case 0x3c:\n          return '\\\\u003c'\n        case 0x3e:\n          return '\\\\u003e'\n        case 0x26:\n          return '\\\\u0026'\n        /* istanbul ignore next: unreachable default */\n        default:\n          return c\n      }",
    "comment": "* Stringify JSON, like JSON.stringify, but v8 optimized, with the\n * ability to escape characters that can trigger HTML sniffing.\n *\n * @param {*} value\n * @param {function} replacer\n * @param {number} spaces\n * @param {boolean} escape\n * @returns {string}\n * @private",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/response.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function acceptParams (str) {\n  var length = str.length;\n  var colonIndex = str.indexOf(';');\n  var index = colonIndex === -1 ? length : colonIndex;\n  var ret = { value: str.slice(0, index).trim(), quality: 1, params: {}",
    "comment": "* Parse accept params `str` returning an\n * object with `.value`, `.quality` and `.params`.\n *\n * @param {String} str\n * @return {Object}\n * @api private",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/utils.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function compileQueryParser(val) {\n  var fn;\n\n  if (typeof val === 'function') {\n    return val;\n  }",
    "comment": "* Compile \"query parser\" value to function.\n *\n * @param  {String|Function} val\n * @return {Function}\n * @api private",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/utils.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createETagGenerator (options) {\n  return function generateETag (body, encoding) {\n    var buf = !Buffer.isBuffer(body)\n      ? Buffer.from(body, encoding)\n      : body\n\n    return etag(buf, options)\n  }",
    "comment": "* Create an ETag generator function, generating ETags with\n * the given options.\n *\n * @param {object} options\n * @return {function}\n * @private",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/utils.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function render(options, callback) {\n  var sync = true;\n\n  debug('render \"%s\"', this.path);\n\n  // render, normalizing sync callbacks\n  this.engine(this.path, options, function onRender() {\n    if (!sync) {\n      return callback.apply(this, arguments);\n    }",
    "comment": "* Render with the given options.\n *\n * @param {object} options\n * @param {function} callback\n * @private",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/view.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function tryStat(path) {\n  debug('stat \"%s\"', path);\n\n  try {\n    return fs.statSync(path);\n  }",
    "comment": "* Return a stat, maybe.\n *\n * @param {string} path\n * @return {fs.Stats}\n * @private",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/view.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function replaceRange(range, html) {\n  range.deleteContents();\n\n  // Create a DocumentFragment to insert and populate it with HTML\n  const documentFragment = Utils.safelyParseHTML(html, range.startContainer.ownerDocument);\n\n  // After inserting the node contents, the node is empty. So we need to save a\n  // reference to the element that we need to return.\n  const newElement = documentFragment.firstChild;\n\n  range.insertNode(documentFragment);\n\n  // In some clients (and maybe some versions of those clients), on some pages,\n  // the newly inserted rendered Markdown will be selected. It looks better and\n  // is slightly less annoying if the text is not selected, and consistency\n  // across platforms is good. So we're going to collapse the selection.\n  // Note that specifying the `toStart` argument to `true` seems to be necessary\n  // in order to actually get a cursor in the editor.\n  // Fixes #427: https://github.com/adam-p/markdown-here/issues/427\n  range.collapse(true);\n\n  return newElement;\n}",
    "comment": "* Replaces the contents of `range` with the HTML string in `html`.\n * Returns the element that is created from `html`.\n * @param {Range} range\n * @param {string} html\n * @returns {Element}",
    "language": "javascript",
    "repo": "adam-p/markdown-here",
    "file_path": "src/common/markdown-here.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function convertHTMLtoMarkdown(tag, html) {\n  if (tag === 'a') {\n    var htmlToRestore = [];\n    html = html.replace(/(`+)[\\s\\S]+?\\1/ig, function($0) {\n      var replacement = Math.random();\n      htmlToRestore.push([replacement, $0]);\n      return replacement;\n    }",
    "comment": "Converts instances of `tag` in `html` to Markdown and returns the\nresulting HTML.",
    "language": "javascript",
    "repo": "adam-p/markdown-here",
    "file_path": "src/common/mdh-html-to-text.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function safelyParseHTML(htmlString, ownerDocument, allowStyleTags=false) {\n  ownerDocument = ownerDocument || document;\n\n  // DOMPurify is required for security\n  if (typeof DOMPurify === 'undefined') {\n    throw new Error('DOMPurify is required but not loaded. Cannot safely parse HTML.');\n  }",
    "comment": "* Safely parse an HTML string into a DocumentFragment without executing scripts.\n * Uses DOMPurify to sanitize and parse HTML into a DocumentFragment.\n *\n * @param {string} htmlString - The HTML string to parse and sanitize.\n * @param {Document} [ownerDocument] - The document to use for creating the fragment. Defaults to the global document.\n * @param {boolean} [allowStyleTags] - Whether to allow <style> tags in the sanitized output.\n * @returns {DocumentFragment} The sanitized DocumentFragment.",
    "language": "javascript",
    "repo": "adam-p/markdown-here",
    "file_path": "src/common/utils.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function error( filename, msg, ...params ) {\n\t\terrors.push( {\n\t\t\tfilename,\n\t\t\tmessage: util.format( msg, ...params ),\n\t\t}",
    "comment": "* The main exported function\n *\n * Start with a directory including a README.md and company-profiles/*.md\n * files, and validate and parse the content of the Markdown files.",
    "language": "javascript",
    "repo": "remoteintech/remote-jobs",
    "file_path": "lib/index.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function useSyncExternalStore(subscribe, getSnapshot) {\n\tconst value = getSnapshot();\n\n\t/**\n\t * @typedef {{ _instance: Store }",
    "comment": "* This is taken from https://github.com/facebook/react/blob/main/packages/use-sync-external-store/src/useSyncExternalStoreShimClient.js#L84\n * on a high level this cuts out the warnings, ... and attempts a smaller implementation\n * @typedef {{ _value: any; _getSnapshot: () => any }} Store",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/hooks.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function isMemo(element) {\n\treturn (\n\t\t!!element &&\n\t\t!!element.displayName &&\n\t\t(typeof element.displayName === 'string' ||\n\t\t\telement.displayName instanceof String) &&\n\t\telement.displayName.startsWith('Memo(')\n\t);\n}",
    "comment": "* Check if the passed element is a Memo node.\n * @param {*} element The element to check\n * @returns {boolean}",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/index.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function unmountComponentAtNode(container) {\n\tif (container._children) {\n\t\tpreactRender(null, container);\n\t\treturn true;\n\t}",
    "comment": "* Remove a component tree from the DOM, including state and event handlers.\n * @param {import('./internal').PreactElement} container\n * @returns {boolean}",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/index.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function findDOMNode(component) {\n\treturn (\n\t\t(component &&\n\t\t\t((component._vnode && component._vnode._dom) ||\n\t\t\t\t(component.nodeType === 1 && component))) ||\n\t\tnull\n\t);\n}",
    "comment": "* Get the matching DOM node for a component\n * @param {import('./internal').Component} component\n * @returns {import('./internal').PreactElement | null}",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/index.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function memo(c, comparer) {\n\tfunction shouldUpdate(nextProps) {\n\t\tlet ref = this.props.ref;\n\t\tlet updateRef = ref == nextProps.ref;\n\t\tif (!updateRef && ref) {\n\t\t\tref.call ? ref(null) : (ref.current = null);\n\t\t}",
    "comment": "* Memoize a component, so that it only updates when the props actually have\n * changed. This was previously known as `React.pure`.\n * @param {import('./internal').FunctionComponent} c functional component\n * @param {(prev: object, next: object) => boolean} [comparer] Custom equality function\n * @returns {import('./internal').FunctionComponent}",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/memo.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function render(vnode, parent, callback) {\n\t// React destroys any existing DOM nodes, see #1727\n\t// ...but only on the first render, see #1828\n\tif (parent._children == null) {\n\t\tparent.textContent = '';\n\t}",
    "comment": "* Proxy render() since React returns a Component reference.\n * @param {import('./internal').VNode} vnode VNode tree to render\n * @param {import('./internal').PreactElement} parent DOM node to render vnode tree into\n * @param {() => void} [callback] Optional callback that will be called after rendering\n * @returns {import('./internal').Component | null} The root component reference or null",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/render.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function shallowDiffers(a, b) {\n\tfor (let i in a) if (i !== '__source' && !(i in b)) return true;\n\tfor (let i in b) if (i !== '__source' && a[i] !== b[i]) return true;\n\treturn false;\n}",
    "comment": "* Check if two objects have a different shape\n * @param {object} a\n * @param {object} b\n * @returns {boolean}",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/util.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function checkPropTypes(\n\ttypeSpecs,\n\tvalues,\n\tlocation,\n\tcomponentName,\n\tgetStack\n) {\n\tObject.keys(typeSpecs).forEach(typeSpecName => {\n\t\tlet error;\n\t\ttry {\n\t\t\terror = typeSpecs[typeSpecName](\n\t\t\t\tvalues,\n\t\t\t\ttypeSpecName,\n\t\t\t\tcomponentName,\n\t\t\t\tlocation,\n\t\t\t\tnull,\n\t\t\t\tReactPropTypesSecret\n\t\t\t);\n\t\t}",
    "comment": "* Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * Adapted from https://github.com/facebook/prop-types/blob/master/checkPropTypes.js\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "debug/src/check-props.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getOwnerStack(vnode) {\n\tconst stack = [vnode];\n\tlet next = vnode;\n\twhile ((next = ownerMap.get(next)) != null) {\n\t\tstack.push(next);\n\t}",
    "comment": "* Return the component stack that was captured up to this point.\n * @param {import('./internal').VNode} vnode\n * @returns {string}",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "debug/src/component-stack.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function setupComponentStack() {\n\tlet oldDiff = options._diff;\n\tlet oldDiffed = options.diffed;\n\tlet oldRoot = options._root;\n\tlet oldVNode = options.vnode;\n\tlet oldRender = options._render;\n\n\toptions.diffed = vnode => {\n\t\tif (isPossibleOwner(vnode)) {\n\t\t\townerStack.pop();\n\t\t}",
    "comment": "* Setup code to capture the component trace while rendering. Note that\n * we cannot simply traverse `vnode._parent` upwards, because we have some\n * debug messages for `this.setState` where the `vnode` is `undefined`.",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "debug/src/component-stack.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function setPageStatus(slideIndex, slideAnchor, anchorLink){\n    var sectionHash = '';\n\n    if(getOptions().anchors.length && !getOptions().lockAnchors){\n\n        //isn't it the first slide?\n        if(slideIndex){\n            if(anchorLink != null){\n                sectionHash = anchorLink;\n            }",
    "comment": "* Sets the state of the website depending on the active section/slide.\n* It changes the URL hash when needed and updates the body class.",
    "language": "javascript",
    "repo": "alvarotrigo/fullPage.js",
    "file_path": "src/js/anchors/setPageStatus.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function setAutoScrolling(value, type){\n    //removing the transformation\n    if(!value){\n        silentScroll(0);\n    }",
    "comment": "* Sets the autoScroll option.\n* It changes the scroll bar visibility and the history of the site as a result.",
    "language": "javascript",
    "repo": "alvarotrigo/fullPage.js",
    "file_path": "src/js/autoScrolling.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getEventData(eventName, v){\n\n    //using functions to run only the necessary bits within the object\n    var paramsPerEvent = {\n        afterRender: function(){\n            return {\n                section: nullOrSection(getState().activeSection),\n                slide: nullOrSlide(getState().activeSection.activeSlide)\n            }",
    "comment": "* Gets the event's data for the given event on the right format.",
    "language": "javascript",
    "repo": "alvarotrigo/fullPage.js",
    "file_path": "src/js/callbacks/fireCallback.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function setVectorIndex(collection, indexDefinition) {\n  const existingIndexes = await collection.listSearchIndexes().toArray();\n  const defaultIndex = existingIndexes.find((index) => index.name === 'default');\n  if (!defaultIndex) {\n    await collection.createSearchIndex({ name: 'default', definition: indexDefinition }",
    "comment": "* Helper function to update or set a vector index in MongoDB Atlas with a new index definition",
    "language": "javascript",
    "repo": "sahat/hackathon-starter",
    "file_path": "controllers/ai.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function sendPasswordlessLoginLinkIfUserExists(user, req) {\n  const token = await User.generateToken();\n  user.loginToken = token;\n  user.loginExpires = Date.now() + 900000; // 15 min\n  user.loginIpHash = User.hashIP(req.ip);\n  await user.save();\n\n  const mailOptions = {\n    to: user.email,\n    from: process.env.SITE_CONTACT_EMAIL,\n    subject: 'Login Link',\n    text: `Hello,\nWe found an existing account for this email. Please use the following link to log in:\n\n${process.env.BASE_URL}",
    "comment": "* Helper to send passwordless login link if a user is trying to create an account\n * but we already have an account for that email address.\n * This process with ambigious flash messages is a part of the security measure to\n * mitigate account enumeration attacks.",
    "language": "javascript",
    "repo": "sahat/hackathon-starter",
    "file_path": "controllers/user.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function validateLogger (logger, strict) {\n  const methods = ['info', 'error', 'debug', 'fatal', 'warn', 'trace', 'child']\n  const missingMethods = logger\n    ? methods.filter(method => !logger[method] || typeof logger[method] !== 'function')\n    : methods\n\n  if (!missingMethods.length) {\n    return true\n  }",
    "comment": "* Determines if a provided logger object meets the requirements\n * of a Fastify compatible logger.\n *\n * @param {object} logger Object to validate.\n * @param {boolean?} strict `true` if the object must be a logger (always throw if any methods missing)\n *\n * @returns {boolean} `true` when the logger meets the requirements.\n *\n * @throws {FST_ERR_LOG_INVALID_LOGGER} When the logger object is\n * missing required methods.",
    "language": "javascript",
    "repo": "fastify/fastify",
    "file_path": "lib/logger-factory.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "class APIError {\n    static codes = {\n        // General\n        'unknown_error': {\n            status: 500,\n            message: () => `An unknown error occurred`,\n        }",
    "comment": "* APIError represents an error that can be sent to the client.\n * @class APIError\n * @property {number} status the HTTP status code\n * @property {string} message the error message\n * @property {object} source the source of the error",
    "language": "javascript",
    "repo": "HeyPuter/puter",
    "file_path": "src/backend/src/api/APIError.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "class PathOrUIDValidator {\n    static validate (req) {\n        const params = req.method === 'GET'\n            ? req.query : req.body ;\n\n        if(!params.path && !params.uid)\n            throw new APIError(400, '`path` or `uid` must be provided.');\n        // `path` must be a string\n        else if (params.path && !params.uid && typeof params.path !== 'string')\n            throw new APIError(400, '`path` must be a string.');\n        // `path` cannot be empty\n        else if(params.path && !params.uid && params.path.trim() === '')\n            throw new APIError(400, '`path` cannot be empty');\n        // `uid` must be a valid uuid\n        else if(params.uid && !params.path && !require('uuid').validate(params.uid))\n            throw new APIError(400, '`uid` must be a valid uuid');\n\n        // resolve path if provided\n        if(params.path)\n            params.path = _path.resolve('/', params.path);\n    }",
    "comment": "* PathOrUIDValidator validates that either `path` or `uid` is present\n * in the request and requires a valid value for the parameter that was\n * used. Additionally, resolves the path if a path was provided.\n * \n * @class PathOrUIDValidator\n * @static\n * @throws {APIError} if `path` and `uid` are both missing\n * @throws {APIError} if `path` and `uid` are both present\n * @throws {APIError} if `path` is not a string\n * @throws {APIError} if `path` is empty\n * @throws {APIError} if `uid` is not a valid uuid",
    "language": "javascript",
    "repo": "HeyPuter/puter",
    "file_path": "src/backend/src/api/PathOrUIDValidator.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "class ClipboardJS {\n  constructor(\n    selector: string | Element | NodeListOf<Element>,\n    options?: ClipboardJS.Options\n  );\n\n  /**\n   * Subscribes to events that indicate the result of a copy/cut operation.\n   * @param type Event type ('success' or 'error').\n   * @param handler Callback function.\n   */\n  on(type: Response, handler: (e: ClipboardJS.Event) => void): this;\n\n  on(type: string, handler: (...args: any[]) => void): this;\n\n  /**\n   * Clears all event bindings.\n   */\n  destroy(): void;\n\n  /**\n   * Checks if clipboard.js is supported\n   */\n  static isSupported(): boolean;\n\n\n  /**\n   * Fires a copy action\n   */\n  static copy(target: string | Element, options?: CopyActionOptions): string;\n\n   /**\n   * Fires a cut action\n   */\n  static cut(target: string | Element): string;\n}",
    "comment": "* Base class which takes one or more elements, adds event listeners to them,\n * and instantiates a new `ClipboardAction` on each click.",
    "language": "javascript",
    "repo": "zenorocha/clipboard.js",
    "file_path": "src/clipboard.d.ts",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createFakeElement(value) {\n  const isRTL = document.documentElement.getAttribute('dir') === 'rtl';\n  const fakeElement = document.createElement('textarea');\n  // Prevent zooming on iOS\n  fakeElement.style.fontSize = '12pt';\n  // Reset box model\n  fakeElement.style.border = '0';\n  fakeElement.style.padding = '0';\n  fakeElement.style.margin = '0';\n  // Move element out of screen horizontally\n  fakeElement.style.position = 'absolute';\n  fakeElement.style[isRTL ? 'right' : 'left'] = '-9999px';\n  // Move element to the same position vertically\n  let yPosition = window.pageYOffset || document.documentElement.scrollTop;\n  fakeElement.style.top = `${yPosition}",
    "comment": "* Creates a fake textarea element with a value.\n * @param {String} value\n * @return {HTMLElement}",
    "language": "javascript",
    "repo": "zenorocha/clipboard.js",
    "file_path": "src/common/create-fake-element.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function mColoring(graph, m) {\n  const colors = new Array(graph.length).fill(0)\n\n  // Check if it's safe to color a vertex with a given color.\n  function isSafe(vertex, color) {\n    for (let i = 0; i < graph.length; i++) {\n      if (graph[vertex][i] && colors[i] === color) {\n        return false\n      }",
    "comment": "* Colors a graph using up to m colors such that no two adjacent vertices share the same color.\n * @param {number[][]} graph - Adjacency matrix of the graph, using 0 for no edge.\n * @param {number} m - The number of colors to use.\n * @returns {?Array.<number>} A valid M-coloring of the graph using colors 1 to m, or null if none exists.\n * @see https://en.wikipedia.org/wiki/Graph_coloring",
    "language": "javascript",
    "repo": "TheAlgorithms/JavaScript",
    "file_path": "Backtracking/MColoringProblem.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getPathPart(grid, x, y, solution, path) {\n  const n = grid.length\n\n  // are we there yet?\n  if (x === n - 1 && y === n - 1 && grid[y][x] === 1) {\n    solution[y][x] = 1\n    return path\n  }",
    "comment": "* Attempts to calculate the remaining path to the target.\n *\n * @param grid The full grid.\n * @param x The current X coordinate.\n * @param y The current Y coordinate.\n * @param solution The current solution matrix.\n * @param path The path we took to get from the source cell to the current location.\n * @returns {string|boolean} Either the path to the target cell or false.",
    "language": "javascript",
    "repo": "TheAlgorithms/JavaScript",
    "file_path": "Backtracking/RatInAMaze.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function _generateId(el) {\n\tlet str = el.tagName + el.className + el.src + el.href + el.textContent,\n\t\ti = str.length,\n\t\tsum = 0;\n\n\twhile (i--) {\n\t\tsum += str.charCodeAt(i);\n\t}",
    "comment": "* Generate id\n * @param   {HTMLElement} el\n * @returns {String}\n * @private",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "src/Sortable.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n\tif (!el.getBoundingClientRect && el !== window) return;\n\n\tlet elRect,\n\t\ttop,\n\t\tleft,\n\t\tbottom,\n\t\tright,\n\t\theight,\n\t\twidth;\n\n\tif (el !== window && el.parentNode && el !== getWindowScrollingElement()) {\n\t\telRect = el.getBoundingClientRect();\n\t\ttop = elRect.top;\n\t\tleft = elRect.left;\n\t\tbottom = elRect.bottom;\n\t\tright = elRect.right;\n\t\theight = elRect.height;\n\t\twidth = elRect.width;\n\t}",
    "comment": "* Returns the \"bounding client rect\" of given element\n * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n * @param  {[HTMLElement]} container              The parent the element will be placed in\n * @return {Object}                               The boundingClientRect of el, with specified adjustments",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "src/utils.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getContentRect(el) {\n\tlet rect = getRect(el);\n\tconst paddingLeft = parseInt(css(el, 'padding-left')),\n\t\tpaddingTop = parseInt(css(el, 'padding-top')),\n\t\tpaddingRight = parseInt(css(el, 'padding-right')),\n\t\tpaddingBottom = parseInt(css(el, 'padding-bottom'));\n\trect.top += paddingTop + parseInt(css(el, 'border-top-width'));\n\trect.left += paddingLeft + parseInt(css(el, 'border-left-width'));\n\t// Client Width/Height includes padding only\n\trect.width = el.clientWidth - paddingLeft - paddingRight;\n\trect.height = el.clientHeight - paddingTop - paddingBottom;\n\trect.bottom = rect.top + rect.height;\n\trect.right = rect.left + rect.width;\n\treturn rect;\n}",
    "comment": "* Returns the content rect of the element (bounding rect minus border and padding)\n * @param {HTMLElement} el",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "src/utils.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function isScrolledPast(el, elSide, parentSide) {\n\tlet parent = getParentAutoScrollElement(el, true),\n\t\telSideVal = getRect(el)[elSide];\n\n\t/* jshint boss:true */\n\twhile (parent) {\n\t\tlet parentSideVal = getRect(parent)[parentSide],\n\t\t\tvisible;\n\n\t\tif (parentSide === 'top' || parentSide === 'left') {\n\t\t\tvisible = elSideVal >= parentSideVal;\n\t\t}",
    "comment": "* Checks if a side of an element is scrolled past a side of its parents\n * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "src/utils.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getChild(el, childNum, options, includeDragEl) {\n\tlet currentChild = 0,\n\t\ti = 0,\n\t\tchildren = el.children;\n\n\twhile (i < children.length) {\n\t\tif (\n\t\t\tchildren[i].style.display !== 'none' &&\n\t\t\tchildren[i] !== Sortable.ghost &&\n\t\t\t(includeDragEl || children[i] !== Sortable.dragged) &&\n\t\t\tclosest(children[i], options.draggable, el, false)\n\t\t) {\n\t\t\tif (currentChild === childNum) {\n\t\t\t\treturn children[i];\n\t\t\t}",
    "comment": "* Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n * and non-draggable elements\n * @param  {HTMLElement} el       The parent element\n * @param  {Number} childNum      The index of the child\n * @param  {Object} options       Parent Sortable's options\n * @return {HTMLElement}          The child at index childNum, or null if not found",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "src/utils.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function lastChild(el, selector) {\n\tlet last = el.lastElementChild;\n\n\twhile (\n\t\tlast &&\n\t\t(\n\t\t\tlast === Sortable.ghost ||\n\t\t\tcss(last, 'display') === 'none' ||\n\t\t\tselector && !matches(last, selector)\n\t\t)\n\t) {\n\t\tlast = last.previousElementSibling;\n\t}",
    "comment": "* Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n * @param  {HTMLElement} el       Parent element\n * @param  {selector} selector    Any other elements that should be ignored\n * @return {HTMLElement}          The last child, ignoring ghostEl",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "src/utils.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function index(el, selector) {\n\tlet index = 0;\n\n\tif (!el || !el.parentNode) {\n\t\treturn -1;\n\t}",
    "comment": "* Returns the index of an element within its parent for a selected set of\n * elements\n * @param  {HTMLElement} el\n * @param  {selector} selector\n * @return {number}",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "src/utils.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getRelativeScrollOffset(el) {\n\tlet offsetLeft = 0,\n\t\toffsetTop = 0,\n\t\twinScroller = getWindowScrollingElement();\n\n\tif (el) {\n\t\tdo {\n\t\t\tlet elMatrix = matrix(el),\n\t\t\t\tscaleX = elMatrix.a,\n\t\t\t\tscaleY = elMatrix.d;\n\n\t\t\toffsetLeft += el.scrollLeft * scaleX;\n\t\t\toffsetTop += el.scrollTop * scaleY;\n\t\t}",
    "comment": "* Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n * The value is returned in real pixels.\n * @param  {HTMLElement} el\n * @return {Array}             Offsets in the format of [left, top]",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "src/utils.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function indexOfObject(arr, obj) {\n\tfor (let i in arr) {\n\t\tif (!arr.hasOwnProperty(i)) continue;\n\t\tfor (let key in obj) {\n\t\t\tif (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n\t\t}",
    "comment": "* Returns the index of the object within the given array\n * @param  {Array} arr   Array that may or may not hold the object\n * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n * @return {Number}      The index of the object in the array, or -1",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "src/utils.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {\n    if (!el.getBoundingClientRect && el !== window) return;\n    var elRect, top, left, bottom, right, height, width;\n    if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {\n      elRect = el.getBoundingClientRect();\n      top = elRect.top;\n      left = elRect.left;\n      bottom = elRect.bottom;\n      right = elRect.right;\n      height = elRect.height;\n      width = elRect.width;\n    }",
    "comment": "* Returns the \"bounding client rect\" of given element\n   * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted\n   * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container\n   * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr\n   * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone\n   * @param  {[HTMLElement]} container              The parent the element will be placed in\n   * @return {Object}                               The boundingClientRect of el, with specified adjustments",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "Sortable.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function isScrolledPast(el, elSide, parentSide) {\n    var parent = getParentAutoScrollElement(el, true),\n      elSideVal = getRect(el)[elSide];\n\n    /* jshint boss:true */\n    while (parent) {\n      var parentSideVal = getRect(parent)[parentSide],\n        visible = void 0;\n      if (parentSide === 'top' || parentSide === 'left') {\n        visible = elSideVal >= parentSideVal;\n      }",
    "comment": "* Checks if a side of an element is scrolled past a side of its parents\n   * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question\n   * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')\n   * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')\n   * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "Sortable.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getChild(el, childNum, options, includeDragEl) {\n    var currentChild = 0,\n      i = 0,\n      children = el.children;\n    while (i < children.length) {\n      if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {\n        if (currentChild === childNum) {\n          return children[i];\n        }",
    "comment": "* Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)\n   * and non-draggable elements\n   * @param  {HTMLElement} el       The parent element\n   * @param  {Number} childNum      The index of the child\n   * @param  {Object} options       Parent Sortable's options\n   * @return {HTMLElement}          The child at index childNum, or null if not found",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "Sortable.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function lastChild(el, selector) {\n    var last = el.lastElementChild;\n    while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {\n      last = last.previousElementSibling;\n    }",
    "comment": "* Gets the last child in the el, ignoring ghostEl or invisible elements (clones)\n   * @param  {HTMLElement} el       Parent element\n   * @param  {selector} selector    Any other elements that should be ignored\n   * @return {HTMLElement}          The last child, ignoring ghostEl",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "Sortable.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function index(el, selector) {\n    var index = 0;\n    if (!el || !el.parentNode) {\n      return -1;\n    }",
    "comment": "* Returns the index of an element within its parent for a selected set of\n   * elements\n   * @param  {HTMLElement} el\n   * @param  {selector} selector\n   * @return {number}",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "Sortable.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getRelativeScrollOffset(el) {\n    var offsetLeft = 0,\n      offsetTop = 0,\n      winScroller = getWindowScrollingElement();\n    if (el) {\n      do {\n        var elMatrix = matrix(el),\n          scaleX = elMatrix.a,\n          scaleY = elMatrix.d;\n        offsetLeft += el.scrollLeft * scaleX;\n        offsetTop += el.scrollTop * scaleY;\n      }",
    "comment": "* Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.\n   * The value is returned in real pixels.\n   * @param  {HTMLElement} el\n   * @return {Array}             Offsets in the format of [left, top]",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "Sortable.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function indexOfObject(arr, obj) {\n    for (var i in arr) {\n      if (!arr.hasOwnProperty(i)) continue;\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);\n      }",
    "comment": "* Returns the index of the object within the given array\n   * @param  {Array} arr   Array that may or may not hold the object\n   * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find\n   * @return {Number}      The index of the object in the array, or -1",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "Sortable.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function _detectNearestEmptySortable(x, y) {\n      var ret;\n      sortables.some(function (sortable) {\n        var threshold = sortable[expando].options.emptyInsertThreshold;\n        if (!threshold || lastChild(sortable)) return;\n        var rect = getRect(sortable),\n          insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,\n          insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;\n        if (insideHorizontally && insideVertically) {\n          return ret = sortable;\n        }",
    "comment": "* Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.\n     * @param  {Number} x      X position\n     * @param  {Number} y      Y position\n     * @return {HTMLElement}   Element of the first found nearest Sortable",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "Sortable.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function toArray() {\n      var order = [],\n        el,\n        children = this.el.children,\n        i = 0,\n        n = children.length,\n        options = this.options;\n      for (; i < n; i++) {\n        el = children[i];\n        if (closest(el, options.draggable, this.el, false)) {\n          order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));\n        }",
    "comment": "* Serializes the item into an array of string.\n     * @returns {String[]}",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "Sortable.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function option(name, value) {\n      var options = this.options;\n      if (value === void 0) {\n        return options[name];\n      }",
    "comment": "* Set/get option\n     * @param   {string} name\n     * @param   {*}      [value]\n     * @returns {*}",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "Sortable.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function _generateId(el) {\n    var str = el.tagName + el.className + el.src + el.href + el.textContent,\n      i = str.length,\n      sum = 0;\n    while (i--) {\n      sum += str.charCodeAt(i);\n    }",
    "comment": "* Generate id\n   * @param   {HTMLElement} el\n   * @returns {String}\n   * @private",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "Sortable.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\n\t\t// Use (key + \" \") to avoid collision with native prototype properties\n\t\t// (see https://github.com/jquery/sizzle/issues/157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}",
    "comment": "* Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry",
    "language": "javascript",
    "repo": "layui/layui",
    "file_path": "src/modules/jquery.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function assert( fn ) {\n\tvar el = document.createElement( \"fieldset\" );\n\n\ttry {\n\t\treturn !!fn( el );\n\t}",
    "comment": "* Support testing using an element\n * @param {Function} fn Passed the created element and returns a boolean result",
    "language": "javascript",
    "repo": "layui/layui",
    "file_path": "src/modules/jquery.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\treturn ( nodeName( elem, \"input\" ) || nodeName( elem, \"button\" ) ) &&\n\t\t\telem.type === type;\n\t}",
    "comment": "* Returns a function to use in pseudos for buttons\n * @param {String} type",
    "language": "javascript",
    "repo": "layui/layui",
    "file_path": "src/modules/jquery.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createDisabledPseudo( disabled ) {\n\n\t// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable\n\treturn function( elem ) {\n\n\t\t// Only certain elements can match :enabled or :disabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled\n\t\t// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled\n\t\tif ( \"form\" in elem ) {\n\n\t\t\t// Check for inherited disabledness on relevant non-disabled elements:\n\t\t\t// * listed form-associated elements in a disabled fieldset\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#category-listed\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled\n\t\t\t// * option elements in a disabled optgroup\n\t\t\t//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled\n\t\t\t// All such elements have a \"form\" property.\n\t\t\tif ( elem.parentNode && elem.disabled === false ) {\n\n\t\t\t\t// Option elements defer to a parent optgroup if present\n\t\t\t\tif ( \"label\" in elem ) {\n\t\t\t\t\tif ( \"label\" in elem.parentNode ) {\n\t\t\t\t\t\treturn elem.parentNode.disabled === disabled;\n\t\t\t\t\t}",
    "comment": "* Returns a function to use in pseudos for :enabled/:disabled\n * @param {Boolean} disabled true for :disabled; false for :enabled",
    "language": "javascript",
    "repo": "layui/layui",
    "file_path": "src/modules/jquery.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createPositionalPseudo( fn ) {\n\treturn markFunction( function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction( function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ ( j = matchIndexes[ i ] ) ] ) {\n\t\t\t\t\tseed[ j ] = !( matches[ j ] = seed[ j ] );\n\t\t\t\t}",
    "comment": "* Returns a function to use in pseudos for positionals\n * @param {Function} fn",
    "language": "javascript",
    "repo": "layui/layui",
    "file_path": "src/modules/jquery.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function setDocument( node ) {\n\tvar subWindow,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\t// Support: IE 11+, Edge 17 - 18+\n\t// IE/Edge sometimes throw a \"Permission denied\" error when strict-comparing\n\t// two documents; shallow comparisons work.\n\t// eslint-disable-next-line eqeqeq\n\tif ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}",
    "comment": "* Sets document-related variables once based on the current document\n * @param {Element|Object} [node] An element or document object to use to set the document\n * @returns {Object} Returns the current document",
    "language": "javascript",
    "repo": "layui/layui",
    "file_path": "src/modules/jquery.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function select( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( ( selector = compiled.selector || selector ) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[ 0 ] = match[ 0 ].slice( 0 );\n\t\tif ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === \"ID\" &&\n\t\t\t\tcontext.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {\n\n\t\t\tcontext = ( Expr.find.ID(\n\t\t\t\ttoken.matches[ 0 ].replace( runescape, funescape ),\n\t\t\t\tcontext\n\t\t\t) || [] )[ 0 ];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t}",
    "comment": "* A low-level selection function that works with jQuery's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with jQuery selector compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against",
    "language": "javascript",
    "repo": "layui/layui",
    "file_path": "src/modules/jquery.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function Events(Base) {\n  return class Events extends Base {\n    #intersectionObserver;\n    #isScrolling;\n    #title = dom.$.title;\n\n    // Initialization\n    // =========================================================================\n    /**\n     * Initialize Docsify events\n     * One-time setup of listeners, observers, and tasks.\n     * @void\n     */\n    initEvent() {\n      const { topMargin }",
    "comment": "* @template {!Constructor} T\n * @param {T} Base - The class to extend",
    "language": "javascript",
    "repo": "docsifyjs/docsify",
    "file_path": "src/core/event/index.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function Fetch(Base) {\n  return class Fetch extends Base {\n    #loadNested(path, qs, file, next, vm, first) {\n      path = first ? path : path.replace(/\\/$/, '');\n      path = getParentPath(path);\n\n      if (!path) {\n        return;\n      }",
    "comment": "* @template {!Constructor} T\n * @param {T} Base - The class to extend",
    "language": "javascript",
    "repo": "docsifyjs/docsify",
    "file_path": "src/core/fetch/index.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function compiler(input) {\n  let tokens = tokenizer(input);\n  let ast    = parser(tokens);\n  let newAst = transformer(ast);\n  let output = codeGenerator(newAst);\n\n  // and simply return the output!\n  return output;\n}",
    "comment": "* FINALLY! We'll create our `compiler` function. Here we will link together\n * every part of the pipeline.\n *\n *   1. input  => tokenizer   => tokens\n *   2. tokens => parser      => ast\n *   3. ast    => transformer => newAst\n *   4. newAst => generator   => output",
    "language": "javascript",
    "repo": "jamiebuilds/the-super-tiny-compiler",
    "file_path": "the-super-tiny-compiler.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\tReflect.ownKeys(obj).forEach(key => {\n\t\t\titer(key, obj[key], obj)\n\t\t}",
    "comment": "* Each iterates a map, set or array.\n * Or, if any other kind of object, all of its own properties.\n * Regardless whether they are enumerable or symbols",
    "language": "javascript",
    "repo": "immerjs/immer",
    "file_path": "src/utils/common.ts",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function normalizeNamespace (fn) {\n  return (namespace, map) => {\n    if (typeof namespace !== 'string') {\n      map = namespace\n      namespace = ''\n    }",
    "comment": "* Return a function expect two param contains namespace and map. it will normalize the namespace and then the param's function will handle the new namespace and the map.\n * @param {Function} fn\n * @return {Function}",
    "language": "javascript",
    "repo": "vuejs/vuex",
    "file_path": "src/helpers.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function makeLocalContext (store, namespace, path) {\n  const noNamespace = namespace === ''\n\n  const local = {\n    dispatch: noNamespace ? store.dispatch : (_type, _payload, _options) => {\n      const args = unifyObjectStyle(_type, _payload, _options)\n      const { payload, options }",
    "comment": "* make localized dispatch, commit, getters and state\n * if there is no namespace, just use root ones",
    "language": "javascript",
    "repo": "vuejs/vuex",
    "file_path": "src/store-util.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function deepCopy (obj, cache = []) {\n  // just return if obj is immutable value\n  if (obj === null || typeof obj !== 'object') {\n    return obj\n  }",
    "comment": "* Deep copy the given object considering circular structure.\n * This function caches all nested objects and its copies.\n * If it detects circular structure, use cached copy to avoid infinite loop.\n *\n * @param {*} obj\n * @param {Array<Object>} cache\n * @return {*}",
    "language": "javascript",
    "repo": "vuejs/vuex",
    "file_path": "src/util.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function refreshHard() {\n  $aosElements = elements();\n\n  if (isDisabled(options.disable) || isBrowserNotSupported()) {\n    return disable();\n  }",
    "comment": "* Hard refresh\n * create array with new elements and trigger refresh",
    "language": "javascript",
    "repo": "michalsnik/aos",
    "file_path": "src/js/aos.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function init(settings) {\n  options = Object.assign(options, settings);\n\n  // Create initial array with elements -> to be fullfilled later with prepare()\n  $aosElements = elements();\n\n  /**\n   * Disable mutation observing if not supported\n   */\n  if (!options.disableMutationObserver && !observer.isSupported()) {\n    console.info(`\n      aos: MutationObserver is not supported on this browser,\n      code mutations observing has been disabled.\n      You may have to call \"refreshHard()\" by yourself.\n    `);\n    options.disableMutationObserver = true;\n  }",
    "comment": "* Initializing AOS\n * - Create options merging defaults with user defined options\n * - Set attributes on <body> as global setting - css relies on it\n * - Attach preparing elements to options.startEvent,\n *   window resize and orientation change\n * - Attach function that handle scroll and everything connected to it\n *   to window scroll event and fire once document is ready to set initial state",
    "language": "javascript",
    "repo": "michalsnik/aos",
    "file_path": "src/js/aos.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "parseDatePeriod: function (expression) {\n\t\tlet matches = expression.match(/^([0-9]+)(y|Q|M|w|d|h|m|s|ms)$/m);\n\t\tif (matches) {\n\t\t\treturn moment().add(matches[1], matches[2]);\n\t\t}",
    "comment": "* Takes an expression such as 30d and returns a moment object of that date in future\n\t *\n\t * Key      Shorthand\n\t * ==================\n\t * years         y\n\t * quarters      Q\n\t * months        M\n\t * weeks         w\n\t * days          d\n\t * hours         h\n\t * minutes       m\n\t * seconds       s\n\t * milliseconds  ms\n\t *\n\t * @param {String}  expression\n\t * @returns {Object}",
    "language": "javascript",
    "repo": "NginxProxyManager/nginx-proxy-manager",
    "file_path": "backend/lib/helpers.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function apiValidator (schema, payload/*, description*/) {\n\treturn new Promise(function Promise_apiValidator (resolve, reject) {\n\t\tif (schema === null) {\n\t\t\treject(new error.ValidationError('Schema is undefined'));\n\t\t\treturn;\n\t\t}",
    "comment": "* @param {Object} schema\n * @param {Object} payload\n * @returns {Promise}",
    "language": "javascript",
    "repo": "NginxProxyManager/nginx-proxy-manager",
    "file_path": "backend/lib/validator/api.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function validator (schema, payload) {\n\treturn new Promise(function (resolve, reject) {\n\t\tif (!payload) {\n\t\t\treject(new error.InternalValidationError('Payload is falsy'));\n\t\t}",
    "comment": "*\n * @param   {Object} schema\n * @param   {Object} payload\n * @returns {Promise}",
    "language": "javascript",
    "repo": "NginxProxyManager/nginx-proxy-manager",
    "file_path": "backend/lib/validator/index.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function humanReadableArgName(arg) {\n  const nameOutput = arg.name() + (arg.variadic === true ? '...' : '');\n\n  return arg.required ? '<' + nameOutput + '>' : '[' + nameOutput + ']';\n}",
    "comment": "* Takes an argument and returns its human readable equivalent for help usage.\n *\n * @param {Argument} arg\n * @return {string}\n * @private",
    "language": "javascript",
    "repo": "tj/commander.js",
    "file_path": "lib/argument.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function incrementNodeInspectorPort(args) {\n  // Testing for these options:\n  //  --inspect[=[host:]port]\n  //  --inspect-brk[=[host:]port]\n  //  --inspect-port=[host:]port\n  return args.map((arg) => {\n    if (!arg.startsWith('--inspect')) {\n      return arg;\n    }",
    "comment": "* Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).\n *\n * @param {string[]} args - array of arguments from node.execArgv\n * @returns {string[]}\n * @private",
    "language": "javascript",
    "repo": "tj/commander.js",
    "file_path": "lib/command.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "class Help {\n  constructor() {\n    this.helpWidth = undefined;\n    this.minWidthToWrap = 40;\n    this.sortSubcommands = false;\n    this.sortOptions = false;\n    this.showGlobalOptions = false;\n  }",
    "comment": "* TypeScript import types for JSDoc, used by Visual Studio Code IntelliSense and `npm run typescript-checkJS`\n * https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html#import-types\n * @typedef { import(\"./argument.js\").Argument } Argument\n * @typedef { import(\"./command.js\").Command } Command\n * @typedef { import(\"./option.js\").Option } Option",
    "language": "javascript",
    "repo": "tj/commander.js",
    "file_path": "lib/help.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function stripColor(str) {\n  // eslint-disable-next-line no-control-regex\n  const sgrPattern = /\\x1b\\[\\d*(;\\d*)*m/g;\n  return str.replace(sgrPattern, '');\n}",
    "comment": "* Strip style ANSI escape sequences from the string. In particular, SGR (Select Graphic Rendition) codes.\n *\n * @param {string} str\n * @returns {string}\n * @package",
    "language": "javascript",
    "repo": "tj/commander.js",
    "file_path": "lib/help.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function suggestSimilar(word, candidates) {\n  if (!candidates || candidates.length === 0) return '';\n  // remove possible duplicates\n  candidates = Array.from(new Set(candidates));\n\n  const searchingOptions = word.startsWith('--');\n  if (searchingOptions) {\n    word = word.slice(2);\n    candidates = candidates.map((candidate) => candidate.slice(2));\n  }",
    "comment": "* Find close matches, restricted to same number of edits.\n *\n * @param {string} word\n * @param {string[]} candidates\n * @returns {string}",
    "language": "javascript",
    "repo": "tj/commander.js",
    "file_path": "lib/suggestSimilar.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function barPositionCSS(n, speed, ease) {\n    var barCSS;\n\n    if (Settings.positionUsing === 'translate3d') {\n      barCSS = { transform: 'translate3d('+toBarPerc(n)+'%,0,0)' }",
    "comment": "* (Internal) returns the correct CSS for changing the bar's\n   * position given an n percentage, and speed and ease from Settings",
    "language": "javascript",
    "repo": "rstacruz/nprogress",
    "file_path": "nprogress.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function stringToArgs(string) {\n  var args = [];\n\n  var parts = string.split(' ');\n  var length = parts.length;\n  var i = 0;\n  var open = false;\n  var grouped = '';\n  var lead = '';\n\n  for (; i < length; i++) {\n    lead = parts[i].substring(0, 1);\n    if (lead === '\"' || lead === '\\'') {\n      open = lead;\n      grouped = parts[i].substring(1);\n    }",
    "comment": "* Converts a string to command line args, in particular\n * groups together quoted values.\n * This is a utility function to allow calling nodemon as a required\n * library, but with the CLI args passed in (instead of an object).\n *\n * @param  {String} string\n * @return {Array}",
    "language": "javascript",
    "repo": "remy/nodemon",
    "file_path": "lib/cli/index.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function nodemonOption(options, arg, eatNext) {\n  // line separation on purpose to help legibility\n  if (arg === '--help' || arg === '-h' || arg === '-?') {\n    var help = eatNext();\n    options.help = help ? help : true;\n  }",
    "comment": "* Given an argument (ie. from process.argv), sets nodemon\n * options and can eat up the argument value\n *\n * @param {import('../..').NodemonSettings} options object that will be updated\n * @param {String} arg current argument from argv\n * @param {Function} eatNext the callback to eat up the next argument in argv\n * @return {Boolean} false if argument was not a nodemon arg",
    "language": "javascript",
    "repo": "remy/nodemon",
    "file_path": "lib/cli/parse.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function parseDelay(value) {\n  var millisPerSecond = 1000;\n  var millis = 0;\n\n  if (value.match(/^\\d*ms$/)) {\n    // Explicitly parse for milliseconds when using ms time specifier\n    millis = parseInt(value, 10);\n  }",
    "comment": "* Given an argument (ie. from nodemonOption()), will parse and return the\n * equivalent millisecond value or 0 if the argument cannot be parsed\n *\n * @param {String} value argument value given to the --delay option\n * @return {Number} millisecond equivalent of the argument",
    "language": "javascript",
    "repo": "remy/nodemon",
    "file_path": "lib/cli/parse.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function execFromPackage() {\n  // doing a try/catch because we can't use the path.exist callback pattern\n  // or we could, but the code would get messy, so this will do exactly\n  // what we're after - if the file doesn't exist, it'll throw.\n  try {\n    // note: this isn't nodemon's package, it's the user's cwd package\n    var pkg = require(path.join(process.cwd(), 'package.json'));\n    if (pkg.main !== undefined) {\n      // no app found to run - so give them a tip and get the feck out\n      return { exec: null, script: pkg.main }",
    "comment": "* Reads the cwd/package.json file and looks to see if it can load a script\n * and possibly an exec first from package.main, then package.start.\n *\n * @return {Object} exec & script if found",
    "language": "javascript",
    "repo": "remy/nodemon",
    "file_path": "lib/config/exec.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function load(settings, options, config, callback) {\n  config.loaded = [];\n  // first load the root nodemon.json\n  loadFile(options, config, utils.home, function (options) {\n    // then load the user's local configuration file\n    if (settings.configFile) {\n      options.configFile = path.resolve(settings.configFile);\n    }",
    "comment": "* Load the nodemon config, first reading the global root/nodemon.json, then\n * the local nodemon.json to the exec and then overwriting using any user\n * specified settings (i.e. from the cli)\n *\n * @param {Object} settings user defined settings\n * @param {Object} options global options\n * @param {Object} config the config object to be updated\n * @param {Function} callback that receives complete config",
    "language": "javascript",
    "repo": "remy/nodemon",
    "file_path": "lib/config/load.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function computedStyle(elem, pseudo, prop) {\n    var result;\n\n    if ('getComputedStyle' in window) {\n      result = getComputedStyle.call(window, elem, pseudo);\n      var console = window.console;\n\n      if (result !== null) {\n        if (prop) {\n          result = result.getPropertyValue(prop);\n        }",
    "comment": "* wrapper around getComputedStyle, to fix issues with Firefox returning null when\n   * called inside of a hidden iframe\n   *\n   * @access private\n   * @function computedStyle\n   * @param {HTMLElement|SVGElement} elem - The element we want to find the computed styles of\n   * @param {string|null} [pseudo] - An optional pseudo element selector (e.g. :before), of null if none\n   * @param {string} prop - A CSS property\n   * @returns {CSSStyleDeclaration} the value of the specified CSS property",
    "language": "javascript",
    "repo": "Modernizr/Modernizr",
    "file_path": "src/computedStyle.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createElement() {\n    if (typeof document.createElement !== 'function') {\n      // This is the case in IE7, where the type of createElement is \"object\".\n      // For this reason, we cannot call apply() as Object is not a Function.\n      return document.createElement(arguments[0]);\n    }",
    "comment": "* createElement is a convenience wrapper around document.createElement. Since we\n   * use createElement all over the place, this allows for (slightly) smaller code\n   * as well as abstracting away issues with creating elements in contexts other than\n   * HTML documents (e.g. SVG documents).\n   *\n   * @access private\n   * @function createElement\n   * @returns {HTMLElement|SVGElement} An HTML or SVG element",
    "language": "javascript",
    "repo": "Modernizr/Modernizr",
    "file_path": "src/createElement.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getAttrs(element) {\n  return Array.from(element.attributes).reduce((attrs, attr) => {\n    attrs[attr.name] = attr.value;\n    return attrs;\n  }",
    "comment": "* Get the attributes of an HTML element.\n * @param {HTMLElement} element\n * @returns {Object}",
    "language": "javascript",
    "repo": "feathericons/feather",
    "file_path": "src/replace.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function toSvg(name, attrs = {}) {\n  console.warn(\n    'feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead.',\n  );\n\n  if (!name) {\n    throw new Error('The required `key` (icon name) parameter is missing.');\n  }",
    "comment": "* Create an SVG string.\n * @deprecated\n * @param {string} name\n * @param {Object} attrs\n * @returns {string}",
    "language": "javascript",
    "repo": "feathericons/feather",
    "file_path": "src/to-svg.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function setAttrs(svg) {\n  const $ = cheerio.load(svg);\n\n  Object.keys(DEFAULT_ATTRS).forEach(key =>\n    $('svg').attr(key, DEFAULT_ATTRS[key]),\n  );\n\n  return $('body').html();\n}",
    "comment": "* Set default attributes on SVG.\n * @param {string} svg - An SVG string.\n * @returns {string}",
    "language": "javascript",
    "repo": "feathericons/feather",
    "file_path": "bin/optimize-svg.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {\n    const keywordHits = Object.create(null);\n\n    /**\n     * Return keyword data if a match is a keyword\n     * @param {CompiledMode}",
    "comment": "* private highlight that's used internally and does not fire callbacks\n   *\n   * @param {string} languageName - the language to use for highlighting\n   * @param {string} codeToHighlight - the code to highlight\n   * @param {boolean?} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   * @param {CompiledMode?} [continuation] - current continuation mode, if any\n   * @returns {HighlightResult} - result of the highlight operation",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function endOfMode(mode, match, matchPlusRemainder) {\n      let matched = regex.startsWith(mode.endRe, matchPlusRemainder);\n\n      if (matched) {\n        if (mode[\"on:end\"]) {\n          const resp = new Response(mode);\n          mode[\"on:end\"](match, resp);\n          if (resp.isMatchIgnored) matched = false;\n        }",
    "comment": "* @param {CompiledMode } mode - the mode to potentially end\n     * @param {RegExpMatchArray} match - the latest match\n     * @param {string} matchPlusRemainder - match plus remainder of content\n     * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function doIgnore(lexeme) {\n      if (top.matcher.regexIndex === 0) {\n        // no more regexes to potentially match here, so we move the cursor forward one\n        // space\n        modeBuffer += lexeme[0];\n        return 1;\n      }",
    "comment": "* Handle matching but then ignoring a sequence of text\n     *\n     * @param {string} lexeme - string containing full match text",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function doBeginMatch(match) {\n      const lexeme = match[0];\n      const newMode = match.rule;\n\n      const resp = new Response(newMode);\n      // first internal before callbacks, then the public ones\n      const beforeCallbacks = [newMode.__beforeBegin, newMode[\"on:begin\"]];\n      for (const cb of beforeCallbacks) {\n        if (!cb) continue;\n        cb(match, resp);\n        if (resp.isMatchIgnored) return doIgnore(lexeme);\n      }",
    "comment": "* Handle the start of a new potential mode match\n     *\n     * @param {EnhancedMatch} match - the current match\n     * @returns {number} how far to advance the parse cursor",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function doEndMatch(match) {\n      const lexeme = match[0];\n      const matchPlusRemainder = codeToHighlight.substring(match.index);\n\n      const endMode = endOfMode(top, match, matchPlusRemainder);\n      if (!endMode) { return NO_MATCH; }",
    "comment": "* Handle the potential end of mode\n     *\n     * @param {RegExpMatchArray} match - the current match",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function processLexeme(textBeforeMatch, match) {\n      const lexeme = match && match[0];\n\n      // add non-matched text to the current mode buffer\n      modeBuffer += textBeforeMatch;\n\n      if (lexeme == null) {\n        processBuffer();\n        return 0;\n      }",
    "comment": "*  Process an individual match\n     *\n     * @param {string} textBeforeMatch - text preceding the match (since the last match)\n     * @param {EnhancedMatch} [match] - the match itself",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function justTextHighlightResult(code) {\n    const result = {\n      value: escape(code),\n      illegal: false,\n      relevance: 0,\n      _top: PLAINTEXT_LANGUAGE,\n      _emitter: new options.__emitter(options)\n    }",
    "comment": "* returns a valid highlight result, without actually doing any actual work,\n   * auto highlight starts with this and it's possible for small snippets that\n   * auto-detection may not find a better match\n   * @param {string} code\n   * @returns {HighlightResult}",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function highlightAuto(code, languageSubset) {\n    languageSubset = languageSubset || options.languages || Object.keys(languages);\n    const plaintext = justTextHighlightResult(code);\n\n    const results = languageSubset.filter(getLanguage).filter(autoDetection).map(name =>\n      _highlight(name, code, false)\n    );\n    results.unshift(plaintext); // plaintext is always an option\n\n    const sorted = results.sort((a, b) => {\n      // sort base on relevance\n      if (a.relevance !== b.relevance) return b.relevance - a.relevance;\n\n      // always award the tie to the base language\n      // ie if C++ and Arduino are tied, it's more likely to be C++\n      if (a.language && b.language) {\n        if (getLanguage(a.language).supersetOf === b.language) {\n          return 1;\n        }",
    "comment": "Highlighting with language detection. Accepts a string with the code to\n  highlight. Returns an object with the following properties:\n\n  - language (detected language)\n  - relevance (int)\n  - value (an HTML string with highlighting markup)\n  - secondBest (object with the same structure for second-best heuristically\n    detected language, may be absent)\n\n    @param {string} code\n    @param {Array<string>} [languageSubset]\n    @returns {AutoHighlightResult}",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function updateClassName(element, currentLang, resultLang) {\n    const language = (currentLang && aliases[currentLang]) || resultLang;\n\n    element.classList.add(\"hljs\");\n    element.classList.add(`language-${language}",
    "comment": "* Builds new class name for block given the language name\n   *\n   * @param {HTMLElement} element\n   * @param {string} [currentLang]\n   * @param {string} [resultLang]",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function normalizeSingleTouches(ev, type) {\n  let all = toArray(ev.touches);\n  let changed = toArray(ev.changedTouches);\n\n  if (type & (INPUT_END | INPUT_CANCEL)) {\n    all = uniqueArray(all.concat(changed), 'identifier', true);\n  }",
    "comment": "* @private\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]",
    "language": "javascript",
    "repo": "hammerjs/hammer.js",
    "file_path": "src/input/singletouch.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function computeIntervalInputData(session, input) {\n  let last = session.lastInterval || input;\n  let deltaTime = input.timeStamp - last.timeStamp;\n  let velocity;\n  let velocityX;\n  let velocityY;\n  let direction;\n\n  if (input.eventType !== INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {\n    let deltaX = input.deltaX - last.deltaX;\n    let deltaY = input.deltaY - last.deltaY;\n\n    let v = getVelocity(deltaTime, deltaX, deltaY);\n    velocityX = v.x;\n    velocityY = v.y;\n    velocity = (abs(v.x) > abs(v.y)) ? v.x : v.y;\n    direction = getDirection(deltaX, deltaY);\n\n    session.lastInterval = input;\n  }",
    "comment": "* @private\n * velocity is calculated every x ms\n * @param {Object} session\n * @param {Object} input",
    "language": "javascript",
    "repo": "hammerjs/hammer.js",
    "file_path": "src/inputjs/compute-interval-input-data.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getCenter(pointers) {\n  let pointersLength = pointers.length;\n\n  // no need to loop when only one touch\n  if (pointersLength === 1) {\n    return {\n      x: round(pointers[0].clientX),\n      y: round(pointers[0].clientY)\n    }",
    "comment": "* @private\n * get the center of all the pointers\n * @param {Array} pointers\n * @return {Object} center contains `x` and `y` properties",
    "language": "javascript",
    "repo": "hammerjs/hammer.js",
    "file_path": "src/inputjs/get-center.js",
    "quality_score": 0.7,
    "comment_type": "jsdoc"
  },
  {
    "code": "const generateKeyMatrix = (keyString) => {\n  const matrixSize = Math.sqrt(keyString.length);\n  if (!Number.isInteger(matrixSize)) {\n    throw new Error(\n      'Invalid key string length. The square root of the key string must be an integer',\n    );\n  }",
    "comment": "* Generates key matrix from given keyString.\n *\n * @param {string} keyString - a string to build a key matrix (must be of matrixSize^2 length).\n * @return {number[][]} keyMatrix",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/cryptography/hill-cipher/hillCipher.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "const getNextDirection = ({ railCount, currentRail, direction }) => {\n  switch (currentRail) {\n    case 0:\n      // Go down if we're on top of the fence.\n      return DIRECTIONS.DOWN;\n    case railCount - 1:\n      // Go up if we're at the bottom of the fence.\n      return DIRECTIONS.UP;\n    default:\n      // Continue with the same direction if we're in the middle of the fence.\n      return direction;\n  }",
    "comment": "* Get next direction to move (based on the current one) while traversing the fence.\n *\n * @param {object} params\n * @param {number} params.railCount - Number of rows in the fence\n * @param {number} params.currentRail - Current row that we're visiting\n * @param {Direction} params.direction - Current direction\n * @returns {Direction} - The next direction to take",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/cryptography/rail-fence-cipher/railFenceCipher.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "const uptimeFetcher = (variables, token) => {\n  return request(\n    {\n      query: `\n        query {\n          rateLimit {\n            remaining\n            resetAt\n          }",
    "comment": "* Simple uptime check fetcher for the PATs.\n *\n * @param {AxiosRequestHeaders} variables Fetcher variables.\n * @param {string} token GitHub token.\n * @returns {Promise<AxiosResponse>} The response.",
    "language": "javascript",
    "repo": "anuraghazra/github-readme-stats",
    "file_path": "api/status/pat-info.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "const uptimeFetcher = (variables, token) => {\n  return request(\n    {\n      query: `\n        query {\n          rateLimit {\n              remaining\n          }",
    "comment": "* Simple uptime check fetcher for the PATs.\n *\n * @param {AxiosRequestHeaders} variables Fetcher variables.\n * @param {string} token GitHub token.\n * @returns {Promise<AxiosResponse>} The response.",
    "language": "javascript",
    "repo": "anuraghazra/github-readme-stats",
    "file_path": "api/status/up.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "const renderRepoCard = (repo, options = {}) => {\n  const {\n    name,\n    nameWithOwner,\n    description,\n    primaryLanguage,\n    isArchived,\n    isTemplate,\n    starCount,\n    forkCount,\n  }",
    "comment": "* Renders repository card details.\n *\n * @param {RepositoryData} repo Repository data.\n * @param {Partial<RepoCardOptions>} options Card options.\n * @returns {string} Repository card SVG object.",
    "language": "javascript",
    "repo": "anuraghazra/github-readme-stats",
    "file_path": "src/cards/repo-card.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "const polarToCartesian = (centerX, centerY, radius, angleInDegrees) => {\n  const rads = degreesToRadians(angleInDegrees);\n  return {\n    x: centerX + radius * Math.cos(rads),\n    y: centerY + radius * Math.sin(rads),\n  }",
    "comment": "* Convert polar coordinates to cartesian coordinates.\n *\n * @param {number} centerX Center x coordinate.\n * @param {number} centerY Center y coordinate.\n * @param {number} radius Radius of the circle.\n * @param {number} angleInDegrees Angle in degrees.\n * @returns {{x: number, y: number}} Cartesian coordinates.",
    "language": "javascript",
    "repo": "anuraghazra/github-readme-stats",
    "file_path": "src/cards/top-languages-card.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "const handleRequest = (req, res) => {\n      const ctx = this.createContext(req, res)\n      if (!this.ctxStorage) {\n        return this.handleRequest(ctx, fn)\n      }",
    "comment": "* Return a request handler callback\n   * for node's native http server.\n   *\n   * @return {Function}\n   * @api public",
    "language": "javascript",
    "repo": "koajs/koa",
    "file_path": "lib/application.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "const fakeCopyAction = (value, options) => {\n  const fakeElement = createFakeElement(value);\n  options.container.appendChild(fakeElement);\n  const selectedText = select(fakeElement);\n  command('copy');\n  fakeElement.remove();\n\n  return selectedText;\n}",
    "comment": "* Create fake copy action wrapper using a fake element.\n * @param {String} target\n * @param {Object} options\n * @return {String}",
    "language": "javascript",
    "repo": "zenorocha/clipboard.js",
    "file_path": "src/actions/copy.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "const ClipboardActionCut = (target) => {\n  const selectedText = select(target);\n  command('cut');\n  return selectedText;\n}",
    "comment": "* Cut action wrapper.\n * @param {String|HTMLElement} target\n * @return {String}",
    "language": "javascript",
    "repo": "zenorocha/clipboard.js",
    "file_path": "src/actions/cut.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "const generateParentheses = (n) => {\n  const res = []\n\n  const solve = (chres, openParenthese, closedParenthese) => {\n    if (openParenthese === n && closedParenthese === n) {\n      res.push(chres)\n      return\n    }",
    "comment": "* Problem Statement: Given a number n pairs of parentheses, try to Generate all combinations of valid parentheses;\n * @param {number} n - number of given parentheses\n * @return {string[]} res - array that contains all valid parentheses\n * @see https://leetcode.com/problems/generate-parentheses/",
    "language": "javascript",
    "repo": "TheAlgorithms/JavaScript",
    "file_path": "Backtracking/generateParentheses.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "pathname: function() {\n        var pathname = href\n          ? function(){\n            var str = (href.match(/\\.[^.]+?\\/.+/) || [])[0] || '';\n            return str.replace(/^[^\\/]+/, '').replace(/\\?.+/, '');\n          }",
    "comment": "* URL 解析\n   * @param {string} href - url 路径\n   * @returns {Object}",
    "language": "javascript",
    "repo": "layui/layui",
    "file_path": "src/layui.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "writeText: function(options) {\n      var text = String(options.text);\n\n      if(navigator && 'clipboard' in navigator){\n        navigator.clipboard.writeText(text)\n          .then(options.done, function(){\n            legacyCopy();\n        }",
    "comment": "* 写入文本\n     * @param {Object} options - 可配置的选项\n     * @param {string} options.text - 写入剪贴板的文本\n     * @param {() => void} [options.done] - 写入成功/完成回调\n     * @param {(err?: any) => void} [options.error] - 写入失败回调\n     * @example\n     * ```js\n     * lay.clipboard.writeText({\n     *   text: '测试文本',\n     *   done: function(){ layer.msg('copied')},\n     *   error: function(){ layer.msg('error')}\n     * })\n     * ```",
    "language": "javascript",
    "repo": "layui/layui",
    "file_path": "src/modules/lay.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "const fireEvent = (eventName, data) => {\n  let customEvent;\n\n  if (detect.ie11()) {\n    customEvent = document.createEvent('CustomEvent');\n    customEvent.initCustomEvent(eventName, true, true, { detail: data }",
    "comment": "* Removes multiple classes from node\n * @param {DOMNode} node\n * @param {array}  classes",
    "language": "javascript",
    "repo": "michalsnik/aos",
    "file_path": "src/js/helpers/handleScroll.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "has: function(key) {\n\t\tinstance === null && configure();\n\t\tconst keys = key.split('.');\n\t\tlet level  = instance;\n\t\tlet has    = true;\n\t\tkeys.forEach((keyItem) =>{\n\t\t\tif (typeof level[keyItem] === 'undefined') {\n\t\t\t\thas = false;\n\t\t\t}",
    "comment": "*\n\t * @param   {string}  key   ie: 'database' or 'database.engine'\n\t * @returns {boolean}",
    "language": "javascript",
    "repo": "NginxProxyManager/nginx-proxy-manager",
    "file_path": "backend/lib/config.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "const listener = (args) => {\n      // The .action callback takes an extra parameter which is the command or options.\n      const expectedArgsCount = this.registeredArguments.length;\n      const actionArgs = args.slice(0, expectedArgsCount);\n      if (this._storeOptionsAsProperties) {\n        actionArgs[expectedArgsCount] = this; // backwards compatible \"options\"\n      }",
    "comment": "* Register callback `fn` for the command.\n   *\n   * @example\n   * program\n   *   .command('serve')\n   *   .description('start service')\n   *   .action(function() {\n   *      // do work here\n   *   });\n   *\n   * @param {Function} fn\n   * @return {Command} `this` command for chaining",
    "language": "javascript",
    "repo": "tj/commander.js",
    "file_path": "lib/command.js",
    "quality_score": 0.6,
    "comment_type": "jsdoc"
  },
  {
    "code": "function range(size, options) {\n  var range = this.get('Range');\n  if (!range) return;\n  return parseRange(size, range, options);\n}",
    "comment": "* Parse Range header field, capping to the given `size`.\n *\n * Unspecified ranges such as \"0-\" require knowledge of your resource length. In\n * the case of a byte range this is of course the total number of bytes. If the\n * Range header field is not given `undefined` is returned, `-1` when unsatisfiable,\n * and `-2` when syntactically invalid.\n *\n * When ranges are returned, the array has a \"type\" property which is the type of\n * range that is required (most commonly, \"bytes\"). Each array element is an object\n * with a \"start\" and \"end\" property for the portion of the range.\n *\n * The \"combine\" option can be set to `true` and overlapping & adjacent ranges\n * will be combined into a single range.\n *\n * NOTE: remember that ranges are inclusive, so for example \"Range: users=0-3\"\n * should respond with 4 users when available, not 3.\n *\n * @param {number} size\n * @param {object} [options]\n * @param {boolean} [options.combine=false]\n * @return {number|array}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.5,
    "comment_type": "jsdoc"
  },
  {
    "code": "function articulationPoints(graph) {\n  // Set of vertices we've already visited during DFS.\n  const visitedSet = {}",
    "comment": "* Tarjan's algorithm for finding articulation points in graph.\n *\n * @param {Graph} graph\n * @return {Object}",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/graph/articulation-points/articulationPoints.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function bellmanFord(graph, startVertex) {\n  const distances = {}",
    "comment": "* @param {Graph} graph\n * @param {GraphVertex} startVertex\n * @return {{distances, previousVertices}}",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/graph/bellman-ford/bellmanFord.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function initCallbacks(callbacks = {}) {\n  const initiatedCallback = callbacks;\n\n  const stubCallback = () => {}",
    "comment": "* @typedef {Object} Callbacks\n *\n * @property {function(vertices: Object): boolean} [allowTraversal] -\n *   Determines whether DFS should traverse from the vertex to its neighbor\n *   (along the edge). By default prohibits visiting the same vertex again.\n *\n * @property {function(vertices: Object)} [enterVertex] - Called when BFS enters the vertex.\n *\n * @property {function(vertices: Object)} [leaveVertex] - Called when BFS leaves the vertex.",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/graph/breadth-first-search/breadthFirstSearch.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function initCallbacks(callbacks = {}) {\n  const initiatedCallback = callbacks;\n\n  const stubCallback = () => {}",
    "comment": "* @typedef {Object} Callbacks\n *\n * @property {function(vertices: Object): boolean} [allowTraversal] -\n *  Determines whether DFS should traverse from the vertex to its neighbor\n *  (along the edge). By default prohibits visiting the same vertex again.\n *\n * @property {function(vertices: Object)} [enterVertex] - Called when DFS enters the vertex.\n *\n * @property {function(vertices: Object)} [leaveVertex] - Called when DFS leaves the vertex.",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/graph/depth-first-search/depthFirstSearch.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function detectUndirectedCycleUsingDisjointSet(graph) {\n  // Create initial singleton disjoint sets for each graph vertex.\n  /** @param {GraphVertex}",
    "comment": "* Detect cycle in undirected graph using disjoint sets.\n *\n * @param {Graph} graph",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/graph/detect-cycle/detectUndirectedCycleUsingDisjointSet.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function dijkstra(graph, startVertex) {\n  // Init helper variables that we will need for Dijkstra algorithm.\n  const distances = {}",
    "comment": "* Implementation of Dijkstra algorithm of finding the shortest paths to graph nodes.\n * @param {Graph} graph - graph we're going to traverse.\n * @param {GraphVertex} startVertex - traversal start vertex.\n * @return {ShortestPaths}",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/graph/dijkstra/dijkstra.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function dispatchBeforeRedirect(options, responseDetails) {\n  if (options.beforeRedirects.proxy) {\n    options.beforeRedirects.proxy(options);\n  }",
    "comment": "* If the proxy or config beforeRedirects functions are defined, call them with the options\n * object.\n *\n * @param {Object<string, any>} options - The options object that was passed to the request.\n *\n * @returns {Object<string, any>}",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/adapters/http.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function executor(c) {\n      cancel = c;\n    }",
    "comment": "* Returns an object that contains a new `CancelToken` and a function that, when called,\n   * cancels the `CancelToken`.",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/cancel/CancelToken.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "class Axios {\n  constructor(instanceConfig) {\n    this.defaults = instanceConfig || {}",
    "comment": "* Create a new instance of Axios\n *\n * @param {Object} instanceConfig The default config for the instance\n *\n * @return {Axios} A new instance of Axios",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/core/Axios.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function forEachHandler(h) {\n      if (h !== null) {\n        fn(h);\n      }",
    "comment": "* Iterate over all the registered interceptors\n   *\n   * This method is particularly useful for skipping over any\n   * interceptors that may have become `null` calling `eject`.\n   *\n   * @param {Function} fn The function to call for each interceptor\n   *\n   * @returns {void}",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/core/InterceptorManager.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function throwIfCancellationRequested(config) {\n  if (config.cancelToken) {\n    config.cancelToken.throwIfRequested();\n  }",
    "comment": "* Throws a `CanceledError` if cancellation has been requested.\n *\n * @param {Object} config The config that is to be used for the request\n *\n * @returns {void}",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/core/dispatchRequest.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function mergeConfig(config1, config2) {\n  // eslint-disable-next-line no-param-reassign\n  config2 = config2 || {}",
    "comment": "* Config-specific merge-function which creates a new config-object\n * by merging two configuration objects together.\n *\n * @param {Object} config1\n * @param {Object} config2\n *\n * @returns {Object} New object resulting from merging config2 to config1",
    "language": "javascript",
    "repo": "axios/axios",
    "file_path": "lib/core/mergeConfig.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function exponential_cdf(x) {\n  return 1 - 2 ** -x;\n}",
    "comment": "* Calculates the exponential cdf.\n *\n * @param {number} x The value.\n * @returns {number} The exponential cdf.",
    "language": "javascript",
    "repo": "anuraghazra/github-readme-stats",
    "file_path": "src/calculateRank.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function log_normal_cdf(x) {\n  // approximation\n  return x / (1 + x);\n}",
    "comment": "* Calculates the log normal cdf.\n *\n * @param {number} x The value.\n * @returns {number} The log normal cdf.",
    "language": "javascript",
    "repo": "anuraghazra/github-readme-stats",
    "file_path": "src/calculateRank.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function updateLanguage(langCode, baseLangCode) {\n    const en = (await import(\"./languages/en.js\")).default;\n    const baseLang = (await import(`./languages/${baseLangCode}",
    "comment": "* Update the specified language file\n * @param {string} langCode Language code to update\n * @param {string} baseLangCode Second language to copy keys from\n * @returns {void}",
    "language": "javascript",
    "repo": "louislam/uptime-kuma",
    "file_path": "extra/update-language-files/index.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "class Backgrounds {\n\n\tconstructor( Reveal ) {\n\n\t\tthis.Reveal = Reveal;\n\n\t}",
    "comment": "* Creates and updates slide backgrounds.",
    "language": "javascript",
    "repo": "hakimel/reveal.js",
    "file_path": "js/controllers/backgrounds.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "class Keyboard {\n\n\tconstructor( Reveal ) {\n\n\t\tthis.Reveal = Reveal;\n\n\t\t// A key:value map of keyboard keys and descriptions of\n\t\t// the actions they trigger\n\t\tthis.shortcuts = {}",
    "comment": "* Handles all reveal.js keyboard interactions.",
    "language": "javascript",
    "repo": "hakimel/reveal.js",
    "file_path": "js/controllers/keyboard.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "class Notes {\n\n\tconstructor( Reveal ) {\n\n\t\tthis.Reveal = Reveal;\n\n\t}",
    "comment": "* Handles the showing of speaker notes",
    "language": "javascript",
    "repo": "hakimel/reveal.js",
    "file_path": "js/controllers/notes.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function defaultConfiguration() {\n  var env = process.env.NODE_ENV || 'development';\n\n  // default settings\n  this.enable('x-powered-by');\n  this.set('etag', 'weak');\n  this.set('env', env);\n  this.set('query parser', 'simple')\n  this.set('subdomain offset', 2);\n  this.set('trust proxy', false);\n\n  // trust proxy inherit back-compat\n  Object.defineProperty(this.settings, trustProxyDefaultSymbol, {\n    configurable: true,\n    value: true\n  }",
    "comment": "* Initialize application configuration.\n * @private",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function route(path) {\n  return this.router.route(path);\n}",
    "comment": "* Proxy to the app `Router#route()`\n * Returns a new `Route` instance for the _path_.\n *\n * Routes are isolated middleware stacks for specific paths.\n * See the Route api docs for details.\n *\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function enabled(setting) {\n  return Boolean(this.set(setting));\n}",
    "comment": "* Check if `setting` is enabled (truthy).\n *\n *    app.enabled('foo')\n *    // => false\n *\n *    app.enable('foo')\n *    app.enabled('foo')\n *    // => true\n *\n * @param {String} setting\n * @return {Boolean}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function disabled(setting) {\n  return !this.set(setting);\n}",
    "comment": "* Check if `setting` is disabled.\n *\n *    app.disabled('foo')\n *    // => true\n *\n *    app.enable('foo')\n *    app.disabled('foo')\n *    // => false\n *\n * @param {String} setting\n * @return {Boolean}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function enable(setting) {\n  return this.set(setting, true);\n}",
    "comment": "* Enable `setting`.\n *\n * @param {String} setting\n * @return {app} for chaining\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function disable(setting) {\n  return this.set(setting, false);\n}",
    "comment": "* Disable `setting`.\n *\n * @param {String} setting\n * @return {app} for chaining\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createApplication() {\n  var app = function(req, res, next) {\n    app.handle(req, res, next);\n  }",
    "comment": "* Create an express application.\n *\n * @return {Function}\n * @api public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/express.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function header(name) {\n  if (!name) {\n    throw new TypeError('name argument is required to req.get');\n  }",
    "comment": "* Return request header.\n *\n * The `Referrer` header field is special-cased,\n * both `Referrer` and `Referer` are interchangeable.\n *\n * Examples:\n *\n *     req.get('Content-Type');\n *     // => \"text/plain\"\n *\n *     req.get('content-type');\n *     // => \"text/plain\"\n *\n *     req.get('Something');\n *     // => undefined\n *\n * Aliased as `req.header()`.\n *\n * @param {String} name\n * @return {String}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function secure(){\n  return this.protocol === 'https';\n}",
    "comment": "* Short-hand for:\n *\n *    req.protocol === 'https'\n *\n * @return {Boolean}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function ip(){\n  var trust = this.app.get('trust proxy fn');\n  return proxyaddr(this, trust);\n}",
    "comment": "* Return the remote address from the trusted proxy.\n *\n * The is the remote address on the socket unless\n * \"trust proxy\" is set.\n *\n * @return {String}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function path() {\n  return parse(this).pathname;\n}",
    "comment": "* Short-hand for `url.parse(req.url).pathname`.\n *\n * @return {String}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function stale(){\n  return !this.fresh;\n}",
    "comment": "* Check if the request is stale, aka\n * \"Last-Modified\" and / or the \"ETag\" for the\n * resource has changed.\n *\n * @return {Boolean}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function xhr(){\n  var val = this.get('X-Requested-With') || '';\n  return val.toLowerCase() === 'xmlhttprequest';\n}",
    "comment": "* Check if the request was an _XMLHttpRequest_.\n *\n * @return {Boolean}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/request.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function status(code) {\n  // Check if the status code is not an integer\n  if (!Number.isInteger(code)) {\n    throw new TypeError(`Invalid status code: ${JSON.stringify(code)}",
    "comment": "* Set the HTTP status code for the response.\n *\n * Expects an integer value between 100 and 999 inclusive.\n * Throws an error if the provided status code is not an integer or if it's outside the allowable range.\n *\n * @param {number} code - The HTTP status code to set.\n * @return {ServerResponse} - Returns itself for chaining methods.\n * @throws {TypeError} If `code` is not an integer.\n * @throws {RangeError} If `code` is outside the range 100 to 999.\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/response.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function sendFile(path, options, callback) {\n  var done = callback;\n  var req = this.req;\n  var res = this;\n  var next = req.next;\n  var opts = options || {}",
    "comment": "* Transfer the file at the given `path`.\n *\n * Automatically sets the _Content-Type_ response header field.\n * The callback `callback(err)` is invoked when the transfer is complete\n * or when an error occurs. Be sure to check `res.headersSent`\n * if you wish to attempt responding, as the header and some data\n * may have already been transferred.\n *\n * Options:\n *\n *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)\n *   - `root`     root directory for relative filenames\n *   - `headers`  object of headers to serve with file\n *   - `dotfiles` serve dotfiles, defaulting to false; can be `\"allow\"` to send them\n *\n * Other options are passed along to `send`.\n *\n * Examples:\n *\n *  The following example illustrates how `res.sendFile()` may\n *  be used as an alternative for the `static()` middleware for\n *  dynamic situations. The code backing `res.sendFile()` is actually\n *  the same code, so HTTP cache support etc is identical.\n *\n *     app.get('/user/:uid/photos/:file', function(req, res){\n *       var uid = req.params.uid\n *         , file = req.params.file;\n *\n *       req.user.mayViewFilesFrom(uid, function(yes){\n *         if (yes) {\n *           res.sendFile('/uploads/' + uid + '/' + file);\n *         } else {\n *           res.send(403, 'Sorry! you cant see that.');\n *         }\n *       });\n *     });\n *\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/response.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function attachment(filename) {\n  if (filename) {\n    this.type(extname(filename));\n  }",
    "comment": "* Set _Content-Disposition_ header to _attachment_ with optional `filename`.\n *\n * @param {String} filename\n * @return {ServerResponse}\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/response.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function clearCookie(name, options) {\n  // Force cookie expiration by setting expires to the past\n  const opts = { path: '/', ...options, expires: new Date(1)}",
    "comment": "* Clear cookie `name`.\n *\n * @param {String} name\n * @param {Object} [options]\n * @return {ServerResponse} for chaining\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/response.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function location(url) {\n  return this.set('Location', encodeUrl(url));\n}",
    "comment": "* Set the location header to `url`.\n *\n * The given `url` can also be \"back\", which redirects\n * to the _Referrer_ or _Referer_ headers or \"/\".\n *\n * Examples:\n *\n *    res.location('/foo/bar').;\n *    res.location('http://example.com');\n *    res.location('../login');\n *\n * @param {String} url\n * @return {ServerResponse} for chaining\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/response.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function render(view, options, callback) {\n  var app = this.req.app;\n  var done = callback;\n  var opts = options || {}",
    "comment": "* Render `view` with the given `options` and optional callback `fn`.\n * When a callback function is given a response will _not_ be made\n * automatically, otherwise a response of _200_ and _text/html_ is given.\n *\n * Options:\n *\n *  - `cache`     boolean hinting to the engine it should cache\n *  - `filename`  filename of the view being rendered\n *\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/response.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function setCharset(type, charset) {\n  if (!type || !charset) {\n    return type;\n  }",
    "comment": "* Set the charset in a given Content-Type string.\n *\n * @param {String} type\n * @param {String} charset\n * @return {String}\n * @api private",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/utils.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function parseExtendedQueryString(str) {\n  return qs.parse(str, {\n    allowPrototypes: true\n  }",
    "comment": "* Parse an extended query string with qs.\n *\n * @param {String} str\n * @return {Object}\n * @private",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/utils.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function View(name, options) {\n  var opts = options || {}",
    "comment": "* Initialize a new `View` with the given `name`.\n *\n * Options:\n *\n *   - `defaultEngine` the default template engine name\n *   - `engines` template engine require() cache\n *   - `root` root path for view lookup\n *\n * @param {string} name\n * @param {object} options\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/view.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function markdownRender(mdText, userprefs, marked, hljs) {\n  function mathify(mathcode) {\n    return userprefs['math-value']\n            .replace(/\\{mathcode\\}",
    "comment": "Using the functionality provided by the functions htmlToText and markdownToHtml,\n render html into pretty text.",
    "language": "javascript",
    "repo": "adam-p/markdown-here",
    "file_path": "src/common/markdown-render.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function processIds(ids, cb) {\n      eachLimit(ids, conf.CONCURRENT_ACTIONS, function(id, next) {\n        that.Client.executeRemote('resetMetaProcessId', id, function(err, res) {\n          if (err) console.error(err);\n          Common.printOut(conf.PREFIX_MSG + 'Resetting meta for process id %d', id);\n          return next();\n        }",
    "comment": "* Reset process counters\n   *\n   * @method resetMetaProcess",
    "language": "javascript",
    "repo": "Unitech/pm2",
    "file_path": "lib/API.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function restartExistingProcessPathOrStartNew(cb) {\n      that.Client.executeRemote('getMonitorData', {}",
    "comment": "* Restart a process with the same full path\n     * Or start it",
    "language": "javascript",
    "repo": "Unitech/pm2",
    "file_path": "lib/API.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function processIds(ids, cb) {\n      Common.printOut(conf.PREFIX_MSG + 'Applying action %s on app [%s](ids: %s)', action_name, process_name, ids);\n\n      if (ids.length <= 2)\n        concurrent_actions = 1;\n\n      if (action_name == 'deleteProcessId')\n        concurrent_actions = 10;\n\n      eachLimit(ids, concurrent_actions, function(id, next) {\n        var opts;\n\n        // These functions need extra param to be passed\n        if (action_name == 'restartProcessId' ||\n          action_name == 'reloadProcessId' ||\n          action_name == 'softReloadProcessId') {\n          var new_env = {}",
    "comment": "* Operate action on specific process id",
    "language": "javascript",
    "repo": "Unitech/pm2",
    "file_path": "lib/API.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function addProcs(proc, value, cb) {\n      (function ex(proc, number) {\n        if (number-- === 0) return cb();\n        Common.printOut(conf.PREFIX_MSG + 'Scaling up application');\n        that.Client.executeRemote('duplicateProcessId', proc.pm2_env.pm_id, ex.bind(this, proc, number));\n      }",
    "comment": "* Scale up/down a process\n   * @method scale",
    "language": "javascript",
    "repo": "Unitech/pm2",
    "file_path": "lib/API.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function uninstall(PM2, module_name, cb) {\n  var module_path = path.join(cst.DEFAULT_MODULE_PATH, module_name);\n\n  Common.logMod(`Removing ${module_name}",
    "comment": "* Retrieve from module package.json the name of each application\n * delete process and delete folder",
    "language": "javascript",
    "repo": "Unitech/pm2",
    "file_path": "lib/API/Modules/TAR.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getUrlInfo(url) {\n\t    const data = {}",
    "comment": "* Getting info about the url. It includes checking isEmail of isInternal\n\t * @param {*} url",
    "language": "javascript",
    "repo": "remoteintech/remote-jobs",
    "file_path": "lib/index.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function forwardRef(fn) {\n\tfunction Forwarded(props) {\n\t\tlet clone = assign({}",
    "comment": "* Pass ref down to a child. This is mainly used in libraries with HOCs that\n * wrap components. Using `forwardRef` there is an easy way to get a reference\n * of the wrapped component instead of one of the wrapper itself.\n * @param {import('./index').ForwardRefRenderFunction} fn\n * @returns {import('./internal').FunctionComponent}",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/forwardRef.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createFactory(type) {\n\treturn createElement.bind(null, type);\n}",
    "comment": "* Legacy version of createElement.\n * @param {import('./internal').VNode[\"type\"]} type The node name or Component constructor",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/index.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function isValidElement(element) {\n\treturn !!element && element.$$typeof === REACT_ELEMENT_TYPE;\n}",
    "comment": "* Check if the passed element is a valid (p)react node.\n * @param {*} element The element to check\n * @returns {boolean}",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/index.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function isFragment(element) {\n\treturn isValidElement(element) && element.type === Fragment;\n}",
    "comment": "* Check if the passed element is a Fragment node.\n * @param {*} element The element to check\n * @returns {boolean}",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/index.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function unstable_batchedUpdates(callback, arg) {\n\treturn callback(arg);\n}",
    "comment": "* In React, `unstable_batchedUpdates` is a legacy feature that was made a no-op\n * outside of legacy mode in React 18 and a no-op across the board in React 19.\n * @template Arg\n * @template Result\n * @param {(arg: Arg) => Result} callback\n * @param {Arg} [arg]\n * @returns {Result}",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/index.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createPortal(vnode, container) {\n\tconst el = createElement(Portal, { _vnode: vnode, _container: container }",
    "comment": "* Create a `Portal` to continue rendering the vnode tree at a different DOM node\n * @param {import('./internal').VNode} vnode The vnode to render\n * @param {import('./internal').PreactElement} container The DOM node to continue rendering in to.",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/portals.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function resetPropWarnings() {\n\tloggedTypeFailures = {}",
    "comment": "* Reset the history of which prop type warnings have been logged.",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "debug/src/check-props.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getDisplayName(vnode) {\n\tif (vnode.type === Fragment) {\n\t\treturn 'Fragment';\n\t}",
    "comment": "* Get human readable name of the component/dom node\n * @param {import('./internal').VNode} vnode\n * @param {import('./internal').VNode} vnode\n * @returns {string}",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "debug/src/component-stack.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getCurrentVNode() {\n\treturn renderStack.length > 0 ? renderStack[renderStack.length - 1] : null;\n}",
    "comment": "* Get the currently rendered `vnode`\n * @returns {import('./internal').VNode | null}",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "debug/src/component-stack.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function splitCommaSeparatedValues (value, limit) {\n  return value.split(',', limit).map(v => v.trim())\n}",
    "comment": "* Split a comma-separated value string into an array of values, with an optional limit.\n * All the values are trimmed of whitespace.\n *\n * @param {string} value - The comma-separated value string to split.\n * @param {number} [limit] - The maximum number of values to return.\n * @returns {string[]} An array of values from the comma-separated string.",
    "language": "javascript",
    "repo": "koajs/koa",
    "file_path": "lib/request.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function toPixelData(node, options) {\n    return draw(node, options || {}",
    "comment": "* @param {Node} node - The DOM Node object to render\n   * @param {Object} options - Rendering options, @see {@link toSvg}\n   * @return {Promise} - A promise that is fulfilled with a Uint8Array containing RGBA pixel data.\n   *",
    "language": "javascript",
    "repo": "carbon-app/carbon",
    "file_path": "lib/dom-to-image.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function toPng(node, options) {\n    options = options || {}",
    "comment": "* @param {Node} node - The DOM Node object to render\n   * @param {Object} options - Rendering options, @see {@link toSvg}\n   * @return {Promise} - A promise that is fulfilled with a PNG image data URL\n   *",
    "language": "javascript",
    "repo": "carbon-app/carbon",
    "file_path": "lib/dom-to-image.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function toJpeg(node, options) {\n    options = options || {}",
    "comment": "* @param {Node} node - The DOM Node object to render\n   * @param {Object} options - Rendering options, @see {@link toSvg}\n   * @return {Promise} - A promise that is fulfilled with a JPEG image data URL\n   *",
    "language": "javascript",
    "repo": "carbon-app/carbon",
    "file_path": "lib/dom-to-image.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function toBlob(node, options) {\n    options = options || {}",
    "comment": "* @param {Node} node - The DOM Node object to render\n   * @param {Object} options - Rendering options, @see {@link toSvg}\n   * @return {Promise} - A promise that is fulfilled with a PNG image blob\n   *",
    "language": "javascript",
    "repo": "carbon-app/carbon",
    "file_path": "lib/dom-to-image.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createSlideArrows(section){\n    var sectionElem = section.item;\n    var arrows = [utils.createElementFromHTML(getOptions().controlArrowsHTML[0]), utils.createElementFromHTML(getOptions().controlArrowsHTML[1])];\n    utils.after(utils.$(SLIDES_WRAPPER_SEL, sectionElem)[0], arrows);\n    utils.addClass(arrows, SLIDES_ARROW);\n    utils.addClass(arrows[0], SLIDES_PREV);\n    utils.addClass(arrows[1], SLIDES_NEXT);\n\n    if(getOptions().controlArrowColor !== '#fff'){\n        utils.css(utils.$(SLIDES_ARROW_NEXT_SEL, sectionElem), {'border-color': 'transparent transparent transparent '+getOptions().controlArrowColor}",
    "comment": "* Creates the control arrows for the given section",
    "language": "javascript",
    "repo": "alvarotrigo/fullPage.js",
    "file_path": "src/js/arrows.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function nullOrSection(el){\n    if(el && !el.item){\n        return new Section(new SectionPanel(el));\n    }",
    "comment": "* Makes sure to only create a Panel object if the element exist",
    "language": "javascript",
    "repo": "alvarotrigo/fullPage.js",
    "file_path": "src/js/callbacks/nullOrSection.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function saveOAuth2UserTokens(req, accessToken, refreshToken, accessTokenExpiration, refreshTokenExpiration, providerName, tokenConfig = {}) {\n  try {\n    let user = await User.findById(req.user._id);\n    if (!user) {\n      // If user is not found in DB, use the one from the request because we are creating a new user\n      user = req.user;\n    }",
    "comment": "* Common function to handle OAuth2 token processing and saving user data.\n *\n * This function is to handle various scenarios that we would run into when it comes to\n * processing the OAuth2 tokens and saving the user data.\n *\n * If we have an existing tokens:\n *    - Updates the access token\n *    - Updates access token expiration if provided\n *    - Updates refresh token if provided\n *    - Updates refresh token expiration if provided\n *    - Removes expiration dates if new tokens don't have them\n *\n * If no tokens exists:\n *    - Creates new token entry with provided tokens and expirations",
    "language": "javascript",
    "repo": "sahat/hackathon-starter",
    "file_path": "config/passport.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function setupRagCollection(db) {\n  // Setup the vector search collections if they don't exist.\n  // We use fileHash to see if a file with the same hash has already been processed,\n  // to avoid duplicate data in the vector DB.\n  // We use fileName to list the files that have been ingested in the frontend.\n  // llm_string and prompt combo is used to see if we have already processed the same LLM query.\n  const ragCollection = await createCollectionForVectorSearch(db, RAG_CHUNKS, [{ fileHash: 1 }",
    "comment": "* Initialize the MongoDB collection for RAG",
    "language": "javascript",
    "repo": "sahat/hackathon-starter",
    "file_path": "controllers/ai.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function configureVectorIndex(db) {\n  const collection = db.collection(RAG_CHUNKS);\n  const sampleDoc = await collection.findOne({ embedding: { $exists: true }",
    "comment": "* Configure or update the vector index dimensions based on our embedding results\n * Do this only once. If you change your embedding model to a different one,\n * you should switch to a new collection, since you need to use the same model that\n * was used to generate the embeddings when performing queries (similarity search, etc.)",
    "language": "javascript",
    "repo": "sahat/hackathon-starter",
    "file_path": "controllers/ai.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function fourOhFour (options) {\n  const { logger, disableRequestLogging }",
    "comment": "* Each fastify instance have a:\n * kFourOhFourLevelInstance: point to a fastify instance that has the 404 handler set\n * kCanSetNotFoundHandler: bool to track if the 404 handler has already been set\n * kFourOhFour: the singleton instance of this 404 module\n * kFourOhFourContext: the context in the reply object where the handler will be executed",
    "language": "javascript",
    "repo": "fastify/fastify",
    "file_path": "lib/fourOhFour.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createChildLogger (context, logger, req, reqId, loggerOpts) {\n  const loggerBindings = {\n    [context.requestIdLogLabel]: reqId\n  }",
    "comment": "* Utility for creating a child logger with the appropriate bindings, logger factory\n * and validation.\n * @param {object} context\n * @param {import('../fastify').FastifyBaseLogger} logger\n * @param {import('../fastify').RawRequestDefaultExpression<any>} req\n * @param {string} reqId\n * @param {import('../types/logger.js').ChildLoggerOptions?} loggerOpts\n *\n * @returns {object} New logger instance, inheriting all parent bindings,\n * with child bindings added.",
    "language": "javascript",
    "repo": "fastify/fastify",
    "file_path": "lib/logger-factory.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function defaultChildLoggerFactory (logger, bindings, opts) {\n  return logger.child(bindings, opts)\n}",
    "comment": "Default factory to create child logger instance\n *\n * @param {import('../fastify.js').FastifyBaseLogger} logger\n * @param {import('../types/logger.js').Bindings} bindings\n * @param {import('../types/logger.js').ChildLoggerOptions} opts\n *\n * @returns {import('../types/logger.js').FastifyBaseLogger}",
    "language": "javascript",
    "repo": "fastify/fastify",
    "file_path": "lib/logger-factory.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getAttributeValue(suffix, element) {\n  const attribute = `data-clipboard-${suffix}",
    "comment": "* Helper function to retrieve attribute value.\n * @param {String} suffix\n * @param {Element} element",
    "language": "javascript",
    "repo": "zenorocha/clipboard.js",
    "file_path": "src/clipboard.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function command(type) {\n  try {\n    return document.execCommand(type);\n  }",
    "comment": "* Executes a given operation type.\n * @param {String} type\n * @return {Boolean}",
    "language": "javascript",
    "repo": "zenorocha/clipboard.js",
    "file_path": "src/common/command.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function generateSubSets(inputArray) {\n  if (!Array.isArray(inputArray)) {\n    throw new Error('Provided input is not an array')\n  }",
    "comment": "* @function generateSubSets\n * @param {Array} inputArray\n * @returns {Array}\n * @example [1,2] -> [[],[1],[2],[1,2]]",
    "language": "javascript",
    "repo": "TheAlgorithms/JavaScript",
    "file_path": "Bit-Manipulation/GenerateSubSets.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function Sortable(el, options) {\n\tif (!(el && el.nodeType && el.nodeType === 1)) {\n\t\tthrow `Sortable: \\`el\\` must be an HTMLElement, not ${ {}",
    "comment": "* @class  Sortable\n * @param  {HTMLElement}  el\n * @param  {Object}       [options]",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "src/Sortable.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function _getInsertDirection(target) {\n\tif (index(dragEl) < index(target)) {\n\t\treturn 1;\n\t}",
    "comment": "* Gets the direction dragEl must be swapped relative to target in order to make it\n * seem that dragEl has been \"inserted\" into that element's position\n * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n * @return {Number}                   Direction dragEl must be swapped",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "src/Sortable.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function Sortable(el, options) {\n    if (!(el && el.nodeType && el.nodeType === 1)) {\n      throw \"Sortable: `el` must be an HTMLElement, not \".concat({}",
    "comment": "* @class  Sortable\n   * @param  {HTMLElement}  el\n   * @param  {Object}       [options]",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "Sortable.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function _getInsertDirection(target) {\n    if (index(dragEl) < index(target)) {\n      return 1;\n    }",
    "comment": "* Gets the direction dragEl must be swapped relative to target in order to make it\n   * seem that dragEl has been \"inserted\" into that element's position\n   * @param  {HTMLElement} target       The target whose position dragEl is being inserted at\n   * @return {Number}                   Direction dragEl must be swapped",
    "language": "javascript",
    "repo": "SortableJS/Sortable",
    "file_path": "Sortable.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}",
    "comment": "* Mark a function for special use by jQuery selector module\n * @param {Function} fn The function to mark",
    "language": "javascript",
    "repo": "layui/layui",
    "file_path": "src/modules/jquery.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\treturn nodeName( elem, \"input\" ) && elem.type === type;\n\t}",
    "comment": "* Returns a function to use in pseudos for input types\n * @param {String} type",
    "language": "javascript",
    "repo": "layui/layui",
    "file_path": "src/modules/jquery.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}",
    "comment": "* Checks a node for validity as a jQuery selector context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value",
    "language": "javascript",
    "repo": "layui/layui",
    "file_path": "src/modules/jquery.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function Lifecycle(Base) {\n  return class Lifecycle extends Base {\n    _hooks = {}",
    "comment": "* @template {!Constructor} T\n * @param {T} Base - The class to extend",
    "language": "javascript",
    "repo": "docsifyjs/docsify",
    "file_path": "src/core/init/lifecycle.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function traverser(ast, visitor) {\n\n  // A `traverseArray` function that will allow us to iterate over an array and\n  // call the next function that we will define: `traverseNode`.\n  function traverseArray(array, parent) {\n    array.forEach(child => {\n      traverseNode(child, parent);\n    }",
    "comment": "* So now we have our AST, and we want to be able to visit different nodes with\n * a visitor. We need to be able to call the methods on the visitor whenever we\n * encounter a node with a matching type.\n *\n *   traverse(ast, {\n *     Program: {\n *       enter(node, parent) {\n *         // ...\n *       },\n *       exit(node, parent) {\n *         // ...\n *       },\n *     },\n *\n *     CallExpression: {\n *       enter(node, parent) {\n *         // ...\n *       },\n *       exit(node, parent) {\n *         // ...\n *       },\n *     },\n *\n *     NumberLiteral: {\n *       enter(node, parent) {\n *         // ...\n *       },\n *       exit(node, parent) {\n *         // ...\n *       },\n *     },\n *   });",
    "language": "javascript",
    "repo": "jamiebuilds/the-super-tiny-compiler",
    "file_path": "the-super-tiny-compiler.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function transformer(ast) {\n\n  // We'll create a `newAst` which like our previous AST will have a program\n  // node.\n  let newAst = {\n    type: 'Program',\n    body: [],\n  }",
    "comment": "* Next up, the transformer. Our transformer is going to take the AST that we\n * have built and pass it to our traverser function with a visitor and will\n * create a new ast.\n *\n * ----------------------------------------------------------------------------\n *   Original AST                     |   Transformed AST\n * ----------------------------------------------------------------------------\n *   {                                |   {\n *     type: 'Program',               |     type: 'Program',\n *     body: [{                       |     body: [{\n *       type: 'CallExpression',      |       type: 'ExpressionStatement',\n *       name: 'add',                 |       expression: {\n *       params: [{                   |         type: 'CallExpression',\n *         type: 'NumberLiteral',     |         callee: {\n *         value: '2'                 |           type: 'Identifier',\n *       }, {                         |           name: 'add'\n *         type: 'CallExpression',    |         },\n *         name: 'subtract',          |         arguments: [{\n *         params: [{                 |           type: 'NumberLiteral',\n *           type: 'NumberLiteral',   |           value: '2'\n *           value: '4'               |         }, {\n *         }, {                       |           type: 'CallExpression',\n *           type: 'NumberLiteral',   |           callee: {\n *           value: '2'               |             type: 'Identifier',\n *         }]                         |             name: 'subtract'\n *       }]                           |           },\n *     }]                             |           arguments: [{\n *   }                                |             type: 'NumberLiteral',\n *                                    |             value: '4'\n * ---------------------------------- |           }, {\n *                                    |             type: 'NumberLiteral',\n *                                    |             value: '2'\n *                                    |           }]\n *  (sorry the other one is longer.)  |         }\n *                                    |       }\n *                                    |     }]\n *                                    |   }\n * ----------------------------------------------------------------------------",
    "language": "javascript",
    "repo": "jamiebuilds/the-super-tiny-compiler",
    "file_path": "the-super-tiny-compiler.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function normalizeMap (map) {\n  if (!isValidMap(map)) {\n    return []\n  }",
    "comment": "* Normalize the map\n * normalizeMap([1, 2, 3]) => [ { key: 1, val: 1 }, { key: 2, val: 2 }, { key: 3, val: 3 } ]\n * normalizeMap({a: 1, b: 2, c: 3}) => [ { key: 'a', val: 1 }, { key: 'b', val: 2 }, { key: 'c', val: 3 } ]\n * @param {Array|Object} map\n * @return {Object}",
    "language": "javascript",
    "repo": "vuejs/vuex",
    "file_path": "src/helpers.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function isValidMap (map) {\n  return Array.isArray(map) || isObject(map)\n}",
    "comment": "* Validate whether given map is valid or not\n * @param {*} map\n * @return {Boolean}",
    "language": "javascript",
    "repo": "vuejs/vuex",
    "file_path": "src/helpers.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getModuleByNamespace (store, helper, namespace) {\n  const module = store._modulesNamespaceMap[namespace]\n  if (__DEV__ && !module) {\n    console.error(`[vuex] module namespace not found in ${helper}",
    "comment": "* Search a special module from store by namespace. if module not exist, print error message.\n * @param {Object} store\n * @param {String} helper\n * @param {String} namespace\n * @return {Object}",
    "language": "javascript",
    "repo": "vuejs/vuex",
    "file_path": "src/helpers.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function formatStoreForInspectorTree (module, path) {\n  return {\n    id: path || 'root',\n    // all modules end with a `/`, we want the last segment only\n    // cart/ -> cart\n    // nested/cart/ -> cart\n    label: extractNameFromPath(path),\n    tags: module.namespaced ? [TAG_NAMESPACED] : [],\n    children: Object.keys(module._children).map((moduleName) =>\n      formatStoreForInspectorTree(\n        module._children[moduleName],\n        path + moduleName + '/'\n      )\n    )\n  }",
    "comment": "* @param {*} module\n * @return {import('@vue/devtools-api').CustomInspectorNode}",
    "language": "javascript",
    "repo": "vuejs/vuex",
    "file_path": "src/plugins/devtool.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function formatStoreForInspectorState (module, getters, path) {\n  getters = path === 'root' ? getters : getters[path]\n  const gettersKeys = Object.keys(getters)\n  const storeState = {\n    state: Object.keys(module.state).map((key) => ({\n      key,\n      editable: true,\n      value: module.state[key]\n    }",
    "comment": "* @param {*} module\n * @return {import('@vue/devtools-api').CustomInspectorState}",
    "language": "javascript",
    "repo": "vuejs/vuex",
    "file_path": "src/plugins/devtool.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function find (list, f) {\n  return list.filter(f)[0]\n}",
    "comment": "* Get the first item that pass the test\n * by second argument function\n *\n * @param {Array} list\n * @param {Function} f\n * @return {*}",
    "language": "javascript",
    "repo": "vuejs/vuex",
    "file_path": "src/util.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function asyncify(func) {\n    if (isAsync(func)) {\n        return function (...args/*, callback*/) {\n            const callback = args.pop()\n            const promise = func.apply(this, args)\n            return handlePromise(promise, callback)\n        }",
    "comment": "* Take a sync function and make it async, passing its return value to a\n * callback. This is useful for plugging sync functions into a waterfall,\n * series, or other async functions. Any arguments passed to the generated\n * function will be passed to the wrapped function (except for the final\n * callback argument). Errors thrown will be passed to the callback.\n *\n * If the function passed to `asyncify` returns a Promise, that promises's\n * resolved/rejected state will be used to call the callback, rather than simply\n * the synchronous return value.\n *\n * This also means you can asyncify ES2017 `async` functions.\n *\n * @name asyncify\n * @static\n * @memberOf module:Utils\n * @method\n * @alias wrapSync\n * @category Util\n * @param {Function} func - The synchronous function, or Promise-returning\n * function to convert to an {@link AsyncFunction}.\n * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be\n * invoked with `(args..., callback)`.\n * @example\n *\n * // passing a regular synchronous function\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(JSON.parse),\n *     function (data, next) {\n *         // data is the result of parsing the text.\n *         // If there was a parsing error, it would have been caught.\n *     }\n * ], callback);\n *\n * // passing a function returning a promise\n * async.waterfall([\n *     async.apply(fs.readFile, filename, \"utf8\"),\n *     async.asyncify(function (contents) {\n *         return db.model.create(contents);\n *     }),\n *     function (model, next) {\n *         // `model` is the instantiated model object.\n *         // If there was an error, this function would be skipped.\n *     }\n * ], callback);\n *\n * // es2017 example, though `asyncify` is not needed if your JS environment\n * // supports async functions out of the box\n * var q = async.queue(async.asyncify(async function(file) {\n *     var intermediateStep = await processFile(file);\n *     return await somePromise(intermediateStep)\n * }));\n *\n * q.push(files);",
    "language": "javascript",
    "repo": "caolan/async",
    "file_path": "lib/asyncify.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function auto(tasks, concurrency, callback) {\n    if (typeof concurrency !== 'number') {\n        // concurrency is optional, shift the args.\n        callback = concurrency;\n        concurrency = null;\n    }",
    "comment": "* Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on\n * their requirements. Each function can optionally depend on other functions\n * being completed first, and each function is run as soon as its requirements\n * are satisfied.\n *\n * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence\n * will stop. Further tasks will not execute (so any other functions depending\n * on it will not run), and the main `callback` is immediately called with the\n * error.\n *\n * {@link AsyncFunction}s also receive an object containing the results of functions which\n * have completed so far as the first argument, if they have dependencies. If a\n * task function has no dependencies, it will only be passed a callback.\n *\n * @name auto\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {Object} tasks - An object. Each of its properties is either a\n * function or an array of requirements, with the {@link AsyncFunction} itself the last item\n * in the array. The object's key of a property serves as the name of the task\n * defined by that property, i.e. can be used when specifying requirements for\n * other tasks. The function receives one or two arguments:\n * * a `results` object, containing the results of the previously executed\n *   functions, only passed if the task has any dependencies,\n * * a `callback(err, result)` function, which must be called when finished,\n *   passing an `error` (which can be `null`) and the result of the function's\n *   execution.\n * @param {number} [concurrency=Infinity] - An optional `integer` for\n * determining the maximum number of tasks that can be run in parallel. By\n * default, as many as possible.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback. Results are always returned; however, if an\n * error occurs, no further `tasks` will be performed, and the results object\n * will only contain partial results. Invoked with (err, results).\n * @returns {Promise} a promise, if a callback is not passed\n * @example\n *\n * //Using Callbacks\n * async.auto({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }, function(err, results) {\n *     if (err) {\n *         console.log('err = ', err);\n *     }\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * });\n *\n * //Using Promises\n * async.auto({\n *     get_data: function(callback) {\n *         console.log('in get_data');\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         console.log('in make_folder');\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: ['get_data', 'make_folder', function(results, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(results, callback) {\n *         // once the file is written let's email a link to it...\n *         callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *     }]\n * }).then(results => {\n *     console.log('results = ', results);\n *     // results = {\n *     //     get_data: ['data', 'converted to array']\n *     //     make_folder; 'folder',\n *     //     write_file: 'filename'\n *     //     email_link: { file: 'filename', email: 'user@example.com' }\n *     // }\n * }).catch(err => {\n *     console.log('err = ', err);\n * });\n *\n * //Using async/await\n * async () => {\n *     try {\n *         let results = await async.auto({\n *             get_data: function(callback) {\n *                 // async code to get some data\n *                 callback(null, 'data', 'converted to array');\n *             },\n *             make_folder: function(callback) {\n *                 // async code to create a directory to store a file in\n *                 // this is run at the same time as getting the data\n *                 callback(null, 'folder');\n *             },\n *             write_file: ['get_data', 'make_folder', function(results, callback) {\n *                 // once there is some data and the directory exists,\n *                 // write the data to a file in the directory\n *                 callback(null, 'filename');\n *             }],\n *             email_link: ['write_file', function(results, callback) {\n *                 // once the file is written let's email a link to it...\n *                 callback(null, {'file':results.write_file, 'email':'user@example.com'});\n *             }]\n *         });\n *         console.log('results = ', results);\n *         // results = {\n *         //     get_data: ['data', 'converted to array']\n *         //     make_folder; 'folder',\n *         //     write_file: 'filename'\n *         //     email_link: { file: 'filename', email: 'user@example.com' }\n *         // }\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *",
    "language": "javascript",
    "repo": "caolan/async",
    "file_path": "lib/auto.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function concatLimit(coll, limit, iteratee, callback) {\n    var _iteratee = wrapAsync(iteratee);\n    return mapLimit(coll, limit, (val, iterCb) => {\n        _iteratee(val, (err, ...args) => {\n            if (err) return iterCb(err);\n            return iterCb(err, args);\n        }",
    "comment": "* The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.\n *\n * @name concatLimit\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @alias flatMapLimit\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {number} limit - The maximum number of async operations at a time.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @returns A Promise, if no callback is passed",
    "language": "javascript",
    "repo": "caolan/async",
    "file_path": "lib/concatLimit.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function useColor() {\n  // Test for common conventions.\n  // NB: the observed behaviour is in combination with how author adds color! For example:\n  //   - we do not test NODE_DISABLE_COLORS, but util:styletext does\n  //   - we do test NO_COLOR, but Chalk does not\n  //\n  // References:\n  // https://no-color.org\n  // https://bixense.com/clicolors/\n  // https://github.com/nodejs/node/blob/0a00217a5f67ef4a22384cfc80eb6dd9a917fdc1/lib/internal/tty.js#L109\n  // https://github.com/chalk/supports-color/blob/c214314a14bcb174b12b3014b2b0a8de375029ae/index.js#L33\n  // (https://force-color.org recent web page from 2023, does not match major javascript implementations)\n\n  if (\n    process.env.NO_COLOR ||\n    process.env.FORCE_COLOR === '0' ||\n    process.env.FORCE_COLOR === 'false'\n  )\n    return false;\n  if (process.env.FORCE_COLOR || process.env.CLICOLOR_FORCE !== undefined)\n    return true;\n  return undefined;\n}",
    "comment": "* @returns {boolean | undefined}\n * @package",
    "language": "javascript",
    "repo": "tj/commander.js",
    "file_path": "lib/command.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function callFormatItem(term, description) {\n      return helper.formatItem(term, termWidth, description, helper);\n    }",
    "comment": "* Generate the built-in help text.\n   *\n   * @param {Command} cmd\n   * @param {Help} helper\n   * @returns {string}",
    "language": "javascript",
    "repo": "tj/commander.js",
    "file_path": "lib/help.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "class DualOptions {\n  /**\n   * @param {Option[]}",
    "comment": "* This class is to make it easier to work with dual options, without changing the existing\n * implementation. We support separate dual options for separate positive and negative options,\n * like `--build` and `--no-build`, which share a single option value. This works nicely for some\n * use cases, but is tricky for others where we want separate behaviours despite\n * the single shared option value.",
    "language": "javascript",
    "repo": "tj/commander.js",
    "file_path": "lib/option.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function camelcase(str) {\n  return str.split('-').reduce((str, word) => {\n    return str + word[0].toUpperCase() + word.slice(1);\n  }",
    "comment": "* Convert string from kebab-case to camelCase.\n *\n * @param {string} str\n * @return {string}\n * @private",
    "language": "javascript",
    "repo": "tj/commander.js",
    "file_path": "lib/option.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "class Argument {\n  description: string;\n  required: boolean;\n  variadic: boolean;\n  defaultValue?: any;\n  defaultValueDescription?: string;\n  parseArg?: <T>(value: string, previous: T) => T;\n  argChoices?: string[];\n\n  /**\n   * Initialize a new command argument with the given name and description.\n   * The default is that the argument is required, and you can explicitly\n   * indicate this with <> around the name. Put [] around the name for an optional argument.\n   */\n  constructor(arg: string, description?: string);\n\n  /**\n   * Return argument name.\n   */\n  name(): string;\n\n  /**\n   * Set the default value, and optionally supply the description to be displayed in the help.\n   */\n  default(value: unknown, description?: string): this;\n\n  /**\n   * Set the custom handler for processing CLI command arguments into argument values.\n   */\n  argParser<T>(fn: (value: string, previous: T) => T): this;\n\n  /**\n   * Only allow argument value to be one of choices.\n   */\n  choices(values: readonly string[]): this;\n\n  /**\n   * Make argument required.\n   */\n  argRequired(): this;\n\n  /**\n   * Make argument optional.\n   */\n  argOptional(): this;\n}",
    "comment": "suggested exit code which could be used with process.exit",
    "language": "javascript",
    "repo": "tj/commander.js",
    "file_path": "typings/index.d.ts",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function next() {\n      var fn = pending.shift();\n      if (fn) {\n        fn(next);\n      }",
    "comment": "* (Internal) Queues a function to be executed.",
    "language": "javascript",
    "repo": "rstacruz/nprogress",
    "file_path": "nprogress.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function camelCase(string) {\n      return string.replace(/^-ms-/, 'ms-').replace(/-([\\da-z])/gi, function(match, letter) {\n        return letter.toUpperCase();\n      }",
    "comment": "* (Internal) Applies css properties to an element, similar to the jQuery\n   * css method.\n   *\n   * While this helper does assist with vendor prefixed property names, it\n   * does not perform any manipulation of values prior to setting styles.",
    "language": "javascript",
    "repo": "rstacruz/nprogress",
    "file_path": "nprogress.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function hasClass(element, name) {\n    var list = typeof element == 'string' ? element : classList(element);\n    return list.indexOf(' ' + name + ' ') >= 0;\n  }",
    "comment": "* (Internal) Determines if an element or space separated list of class names contains a class name.",
    "language": "javascript",
    "repo": "rstacruz/nprogress",
    "file_path": "nprogress.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function addClass(element, name) {\n    var oldList = classList(element),\n        newList = oldList + name;\n\n    if (hasClass(oldList, name)) return;\n\n    // Trim the opening space.\n    element.className = newList.substring(1);\n  }",
    "comment": "* (Internal) Adds a class to an element.",
    "language": "javascript",
    "repo": "rstacruz/nprogress",
    "file_path": "nprogress.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function removeClass(element, name) {\n    var oldList = classList(element),\n        newList;\n\n    if (!hasClass(element, name)) return;\n\n    // Replace the class name.\n    newList = oldList.replace(' ' + name + ' ', ' ');\n\n    // Trim the opening and closing spaces.\n    element.className = newList.substring(1, newList.length - 1);\n  }",
    "comment": "* (Internal) Removes a class from an element.",
    "language": "javascript",
    "repo": "rstacruz/nprogress",
    "file_path": "nprogress.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function classList(element) {\n    return (' ' + (element && element.className || '') + ' ').replace(/\\s+/gi, ' ');\n  }",
    "comment": "* (Internal) Gets a space separated list of the class names on the element.\n   * The list is wrapped with a single space on each end to facilitate finding\n   * matches within the list.",
    "language": "javascript",
    "repo": "rstacruz/nprogress",
    "file_path": "nprogress.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function parse(argv) {\n  if (typeof argv === 'string') {\n    argv = argv.split(' ');\n  }",
    "comment": "* Parses the command line arguments `process.argv` and returns the\n * nodemon options, the user script and the executable script.\n *\n * @param  {Array<string> | string} argv full process arguments, including `node` leading arg\n * @return {Object} { options, script, args }",
    "language": "javascript",
    "repo": "remy/nodemon",
    "file_path": "lib/cli/parse.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function exec(nodemonOptions, execMap) {\n  if (!execMap) {\n    execMap = {}",
    "comment": "* Discovers all the options required to run the script\n * and if a custom exec has been passed in, then it will\n * also try to work out what extensions to monitor and\n * whether there's a special way of running that script.\n *\n * @param  {Object} nodemonOptions\n * @param  {Object} execMap\n * @return {Object} new and updated version of nodemonOptions",
    "language": "javascript",
    "repo": "remy/nodemon",
    "file_path": "lib/config/exec.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function loadFile(options, config, dir, ready) {\n  if (!ready) {\n    ready = function () {}",
    "comment": "* Looks for a config in the current working directory, and a config in the\n * user's home directory, merging the two together, giving priority to local\n * config. This can then be overwritten later by command line arguments\n *\n * @param  {Function} ready callback to pass loaded settings to",
    "language": "javascript",
    "repo": "remy/nodemon",
    "file_path": "lib/config/load.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function contains(str, substr) {\n    return !!~('' + str).indexOf(substr);\n  }",
    "comment": "* contains checks to see if a string contains another string\n   *\n   * @access private\n   * @function contains\n   * @param {string} str - The string we want to check for substrings\n   * @param {string} substr - The substring we want to search the first string for\n   * @returns {boolean} true if and only if the first string 'str' contains the second string 'substr'",
    "language": "javascript",
    "repo": "Modernizr/Modernizr",
    "file_path": "src/contains.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function attrsToString(attrs) {\n  return Object.keys(attrs)\n    .map(key => `${key}",
    "comment": "* Return string representation of an `Icon`.\n   *\n   * Added for backward compatibility. If old code expects `feather.icons.<name>`\n   * to be a string, `toString()` will get implicitly called.\n   *\n   * @returns {string}",
    "language": "javascript",
    "repo": "feathericons/feather",
    "file_path": "src/icon.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function attrsToString(attrs) {\n  return Object.keys(attrs)\n    .map(key => `${key}",
    "comment": "* Convert attributes object to string of HTML attributes.\n * @param {Object} attrs\n * @returns {string}",
    "language": "javascript",
    "repo": "feathericons/feather",
    "file_path": "src/icon.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function optimizeSvg(svg) {\n  return svgo(svg).then(setAttrs);\n}",
    "comment": "* Optimize SVG string.\n * @param {string} svg - An SVG string.\n * @returns {Promise<string>}",
    "language": "javascript",
    "repo": "feathericons/feather",
    "file_path": "bin/optimize-svg.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function svgo(svg) {\n  const s = new Svgo({\n    plugins: [\n      { convertShapeToPath: false }",
    "comment": "* Run SVGO on SVG string.\n * @param {string} svg - An SVG string.\n * @returns {Promise<string>}",
    "language": "javascript",
    "repo": "feathericons/feather",
    "file_path": "bin/optimize-svg.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function highlight(codeOrLanguageName, optionsOrCode, ignoreIllegals) {\n    let code = \"\";\n    let languageName = \"\";\n    if (typeof optionsOrCode === \"object\") {\n      code = codeOrLanguageName;\n      ignoreIllegals = optionsOrCode.ignoreIllegals;\n      languageName = optionsOrCode.language;\n    }",
    "comment": "* Core highlighting function.\n   *\n   * OLD API\n   * highlight(lang, code, ignoreIllegals, continuation)\n   *\n   * NEW API\n   * highlight(code, {lang, ignoreIllegals})\n   *\n   * @param {string} codeOrLanguageName - the language to use for highlighting\n   * @param {string | HighlightOptions} optionsOrCode - the code to highlight\n   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   *\n   * @returns {HighlightResult} Result - an object that represents the result\n   * @property {string} language - the language name\n   * @property {number} relevance - the relevance score\n   * @property {string} value - the highlighted HTML code\n   * @property {string} code - the original raw code\n   * @property {CompiledMode} top - top of the current mode stack\n   * @property {boolean} illegal - indicates whether any illegal matches were found",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function keywordData(mode, matchText) {\n      return mode.keywords[matchText];\n    }",
    "comment": "* Return keyword data if a match is a keyword\n     * @param {CompiledMode} mode - current mode\n     * @param {string} matchText - the textual match\n     * @returns {KeywordData | false}",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function configure(userOptions) {\n    options = inherit(options, userOptions);\n  }",
    "comment": "* Updates highlight.js global options with the passed options\n   *\n   * @param {Partial<HLJSOptions>} userOptions",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getLanguage(name) {\n    name = (name || '').toLowerCase();\n    return languages[name] || languages[aliases[name]];\n  }",
    "comment": "* @param {string} name - name of the language to retrieve\n   * @returns {Language | undefined}",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "class Hammer {\n  constructor(element, options) {\n    options = options || {}",
    "comment": "* @private\n * Simple way to create a manager with a default set of recognizers.\n * @param {HTMLElement} element\n * @param {Object} [options]\n * @constructor",
    "language": "javascript",
    "repo": "hammerjs/hammer.js",
    "file_path": "src/hammer.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getTouches(ev, type) {\n  let allTouches = toArray(ev.touches);\n  let { targetIds }",
    "comment": "* @private\n * @this {TouchInput}\n * @param {Object} ev\n * @param {Number} type flag\n * @returns {undefined|Array} [all, changed]",
    "language": "javascript",
    "repo": "hammerjs/hammer.js",
    "file_path": "src/input/touch.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function createInputInstance(manager) {\n  let Type;\n  // let inputClass = manager.options.inputClass;\n  let { options:{ inputClass }",
    "comment": "* @private\n * create new input type manager\n * called by the Manager constructor\n * @param {Hammer} manager\n * @returns {Input}",
    "language": "javascript",
    "repo": "hammerjs/hammer.js",
    "file_path": "src/inputjs/create-input-instance.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getAngle(p1, p2, props) {\n  if (!props) {\n    props = PROPS_XY;\n  }",
    "comment": "* @private\n * calculate the angle between two coordinates\n * @param {Object} p1\n * @param {Object} p2\n * @param {Array} [props] containing x and y keys\n * @return {Number} angle",
    "language": "javascript",
    "repo": "hammerjs/hammer.js",
    "file_path": "src/inputjs/get-angle.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getDirection(x, y) {\n  if (x === y) {\n    return DIRECTION_NONE;\n  }",
    "comment": "* @private\n * get the direction between two points\n * @param {Number} x\n * @param {Number} y\n * @return {Number} direction",
    "language": "javascript",
    "repo": "hammerjs/hammer.js",
    "file_path": "src/inputjs/get-direction.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getRotation(start, end) {\n  return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);\n}",
    "comment": "* @private\n * calculate the rotation degrees between two pointersets\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} rotation",
    "language": "javascript",
    "repo": "hammerjs/hammer.js",
    "file_path": "src/inputjs/get-rotation.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getScale(start, end) {\n  return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);\n}",
    "comment": "* @private\n * calculate the scale factor between two pointersets\n * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n * @param {Array} start array of pointers\n * @param {Array} end array of pointers\n * @return {Number} scale",
    "language": "javascript",
    "repo": "hammerjs/hammer.js",
    "file_path": "src/inputjs/get-scale.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function handleClick(e) {\n    e.preventDefault();\n    e.stopPropagation();\n    e.nativeEvent.stopImmediatePropagation();\n}",
    "comment": "* Generic click handler for pages",
    "language": "javascript",
    "repo": "pure-css/pure",
    "file_path": "site/lib/utils.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function Authenticator() {\n  this._key = 'passport';\n  this._strategies = {}",
    "comment": "* Create a new `Authenticator` object.\n *\n * @public\n * @class",
    "language": "javascript",
    "repo": "jaredhanson/passport",
    "file_path": "lib/authenticator.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function SessionStrategy(options, deserializeUser) {\n  if (typeof options == 'function') {\n    deserializeUser = options;\n    options = undefined;\n  }",
    "comment": "*  Create a new `SessionStrategy` object.\n *\n * An instance of this strategy is automatically used when creating an\n * `{@link Authenticator}`.  As such, it is typically unnecessary to create an\n * instance using this constructor.\n *\n * @classdesc This `Strategy` authenticates HTTP requests based on the contents\n * of session data.\n *\n * The login session must have been previously initiated, typically upon the\n * user interactively logging in using a HTML form.  During session initiation,\n * the logged-in user's information is persisted to the session so that it can\n * be restored on subsequent requests.\n *\n * Note that this strategy merely restores the authentication state from the\n * session, it does not authenticate the session itself.  Authenticating the\n * underlying session is assumed to have been done by the middleware\n * implementing session support.  This is typically accomplished by setting a\n * signed cookie, and verifying the signature of that cookie on incoming\n * requests.\n *\n * In {@link https://expressjs.com/ Express}-based apps, session support is\n * commonly provided by {@link https://github.com/expressjs/session `express-session`}\n * or {@link https://github.com/expressjs/cookie-session `cookie-session`}.\n *\n * @public\n * @class\n * @augments base.Strategy\n * @param {Object} [options]\n * @param {string} [options.key='passport'] - Determines what property (\"key\") on\n *          the session data where login session data is located.  The login\n *          session is stored and read from `req.session[key]`.\n * @param {function} deserializeUser - Function which deserializes user.",
    "language": "javascript",
    "repo": "jaredhanson/passport",
    "file_path": "lib/strategies/session.js",
    "quality_score": 0.4,
    "comment_type": "jsdoc"
  },
  {
    "code": "function hotkeyDest( event ) {\n\treturn ( hotkeys.hasOwnProperty( event.key )  ? hotkeys[ event.key ] :\n\t\t hotkeys.hasOwnProperty( event.code ) ? hotkeys[ event.code ] : null ); }",
    "comment": "* Bookmark Plugin\n *\n * The bookmark plugin consists of\n *   a pre-init plugin,\n *   a keyup listener, and\n *   a pre-stepleave plugin.\n *\n * The pre-init plugin surveys all step divs to set up bookmark keybindings.\n * The pre-stepleave plugin alters the destination when a bookmark hotkey is pressed.\n *\n * Example:\n *\n *       <!-- data-bookmark-key-list allows an \"inbound\" style of non-linear navigation. -->\n *       <div id=\"...\" class=\"step\" data-bookmark-key-list=\"Digit1 KeyA 1 2 3 a b c\">\n *\n * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for a table\n * of what strings to use for each key. Both .key and .code styles are recognized.\n *\n * It's up to the HTML author to avoid reserved hotkeys H, B, P, ? etc.\n *\n * Copyright 2016-2017 Henrik Ingo (@henrikingo)\n * Released under the MIT license.",
    "language": "javascript",
    "repo": "impress/impress.js",
    "file_path": "src/plugins/bookmark/bookmark.js",
    "quality_score": 0.30000000000000004,
    "comment_type": "jsdoc"
  },
  {
    "code": "const getCipherMap = (alphabet, shift) => {\n  return alphabet\n    .reduce((charsMap, currentChar, charIndex) => {\n      const charsMapClone = { ...charsMap }",
    "comment": "* Generates a cipher map out of the alphabet.\n * Example with a shift 3: {'a': 'd', 'b': 'e', 'c': 'f', ...}\n *\n * @param {string[]} alphabet - i.e. ['a', 'b', 'c', ... , 'z']\n * @param {number} shift - i.e. 3\n * @return {Object} - i.e. {'a': 'd', 'b': 'e', 'c': 'f', ..., 'z': 'c'}",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/cryptography/caesar-cipher/caesarCipher.js",
    "quality_score": 0.3,
    "comment_type": "jsdoc"
  },
  {
    "code": "const renderGistCard = (gistData, options = {}) => {\n  const { name, nameWithOwner, description, language, starsCount, forksCount }",
    "comment": "* Render gist card.\n *\n * @param {GistData} gistData Gist data.\n * @param {Partial<GistCardOptions>} options Gist card options.\n * @returns {string} Gist card.",
    "language": "javascript",
    "repo": "anuraghazra/github-readme-stats",
    "file_path": "src/cards/gist-card.js",
    "quality_score": 0.3,
    "comment_type": "jsdoc"
  },
  {
    "code": "const createTextNode = ({\n  icon,\n  label,\n  value,\n  id,\n  unitSymbol,\n  index,\n  showIcons,\n  shiftValuePos,\n  bold,\n  number_format,\n}) => {\n  const kValue =\n    number_format.toLowerCase() === \"long\" ? value : kFormatter(value);\n  const staggerDelay = (index + 3) * 150;\n\n  const labelOffset = showIcons ? `x=\"25\"` : \"\";\n  const iconSvg = showIcons\n    ? `\n    <svg data-testid=\"icon\" class=\"icon\" viewBox=\"0 0 16 16\" version=\"1.1\" width=\"16\" height=\"16\">\n      ${icon}",
    "comment": "* Create a stats card text item.\n *\n * @param {object} createTextNodeParams Object that contains the createTextNode parameters.\n * @param {string} createTextNodeParams.icon The icon to display.\n * @param {string} createTextNodeParams.label The label to display.\n * @param {number} createTextNodeParams.value The value to display.\n * @param {string} createTextNodeParams.id The id of the stat.\n * @param {string=} createTextNodeParams.unitSymbol The unit symbol of the stat.\n * @param {number} createTextNodeParams.index The index of the stat.\n * @param {boolean} createTextNodeParams.showIcons Whether to show icons.\n * @param {number} createTextNodeParams.shiftValuePos Number of pixels the value has to be shifted to the right.\n * @param {boolean} createTextNodeParams.bold Whether to bold the label.\n * @param {string} createTextNodeParams.number_format The format of numbers on card.\n * @returns {string} The stats card text item SVG object.",
    "language": "javascript",
    "repo": "anuraghazra/github-readme-stats",
    "file_path": "src/cards/stats-card.js",
    "quality_score": 0.3,
    "comment_type": "jsdoc"
  },
  {
    "code": "const noCodingActivityNode = ({ color, text }) => {\n  return `\n    <text x=\"25\" y=\"11\" class=\"stat bold\" fill=\"${color}",
    "comment": "* Creates the no coding activity SVG node.\n *\n * @param {object} props The function properties.\n * @param {string} props.color No coding activity text color.\n * @param {string} props.text No coding activity translated text.\n * @returns {string} No coding activity SVG node string.",
    "language": "javascript",
    "repo": "anuraghazra/github-readme-stats",
    "file_path": "src/cards/wakatime-card.js",
    "quality_score": 0.3,
    "comment_type": "jsdoc"
  },
  {
    "code": "const ClipboardActionDefault = (options = {}) => {\n  // Defines base properties passed from constructor.\n  const { action = 'copy', container, target, text }",
    "comment": "* Inner function which performs selection from either `text` or `target`\n * properties and then executes copy or cut operations.\n * @param {Object} options",
    "language": "javascript",
    "repo": "zenorocha/clipboard.js",
    "file_path": "src/actions/default.js",
    "quality_score": 0.3,
    "comment_type": "jsdoc"
  },
  {
    "code": "function getCurrentVNode() {\n\treturn renderStack.length > 0 ? renderStack[renderStack.length - 1] : null;\n}",
    "comment": "* Keep track of the current owners. An owner describes a component\n * which was responsible to render a specific `vnode`. This exclude\n * children that are passed via `props.children`, because they belong\n * to the parent owner.\n *\n * ```jsx\n * const Foo = props => <div>{props.children}</div> // div's owner is Foo\n * const Bar = props => {\n *   return (\n *     <Foo><span /></Foo> // Foo's owner is Bar, span's owner is Bar\n *   )\n * }\n * ```\n *\n * Note: A `vnode` may be hoisted to the root scope due to compiler\n * optimiztions. In these cases the owner will be different.",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "debug/src/component-stack.js",
    "quality_score": 0.2,
    "comment_type": "jsdoc"
  },
  {
    "code": "class VisitMetadata {\n  constructor({ discoveryTime, lowDiscoveryTime }",
    "comment": "* Helper class for visited vertex metadata.",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/graph/articulation-points/articulationPoints.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function initCallbacks(callbacks = {}) {\n  const initiatedCallback = callbacks;\n\n  const stubCallback = () => {}",
    "comment": "* @param {Callbacks} [callbacks]\n * @returns {Callbacks}",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/graph/breadth-first-search/breadthFirstSearch.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function graphBridges(graph) {\n  // Set of vertices we've already visited during DFS.\n  const visitedSet = {}",
    "comment": "* @param {Graph} graph\n * @return {Object}",
    "language": "javascript",
    "repo": "trekhleb/javascript-algorithms",
    "file_path": "src/algorithms/graph/bridges/graphBridges.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function engine(ext, fn) {\n  if (typeof fn !== 'function') {\n    throw new Error('callback function required');\n  }",
    "comment": "* Register the given template engine callback `fn`\n * as `ext`.\n *\n * By default will `require()` the engine based on the\n * file extension. For example if you try to render\n * a \"foo.ejs\" file Express will invoke the following internally:\n *\n *     app.engine('ejs', require('ejs').__express);\n *\n * For engines that do not provide `.__express` out of the box,\n * or if you wish to \"map\" a different extension to the template engine\n * you may use this method. For example mapping the EJS template engine to\n * \".html\" files:\n *\n *     app.engine('html', require('ejs').renderFile);\n *\n * In this case EJS provides a `.renderFile()` method with\n * the same signature that Express expects: `(path, options, callback)`,\n * though note that it aliases this method as `ejs.__express` internally\n * so if you're using \".ejs\" extensions you don't need to do anything.\n *\n * Some template engines do not follow this convention, the\n * [Consolidate.js](https://github.com/tj/consolidate.js)\n * library was created to map all of node's popular template\n * engines to follow this convention, thus allowing them to\n * work seamlessly within Express.\n *\n * @param {String} ext\n * @param {Function} fn\n * @return {app} for chaining\n * @public",
    "language": "javascript",
    "repo": "expressjs/express",
    "file_path": "lib/application.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "class API {\n\n  constructor (opts) {\n    if (!opts) opts = {}",
    "comment": "* Main Function to be imported\n * can be aliased to PM2\n *\n * To use it when PM2 is installed as a module:\n *\n * var PM2 = require('pm2');\n *\n * var pm2 = PM2(<opts>);\n *\n *\n * @param {Object}  opts\n * @param {String}  [opts.cwd=<current>]         override pm2 cwd for starting scripts\n * @param {String}  [opts.pm2_home=[<paths.js>]] pm2 directory for log, pids, socket files\n * @param {Boolean} [opts.independent=false]     unique PM2 instance (random pm2_home)\n * @param {Boolean} [opts.daemon_mode=true]      should be called in the same process or not\n * @param {String}  [opts.public_key=null]       pm2 plus bucket public key\n * @param {String}  [opts.secret_key=null]       pm2 plus bucket secret key\n * @param {String}  [opts.machine_name=null]     pm2 plus instance name",
    "language": "javascript",
    "repo": "Unitech/pm2",
    "file_path": "lib/API.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function PureComponent(p, c) {\n\tthis.props = p;\n\tthis.context = c;\n}",
    "comment": "* Component class with a predefined `shouldComponentUpdate` implementation",
    "language": "javascript",
    "repo": "preactjs/preact",
    "file_path": "compat/src/PureComponent.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function setUrlHash(url){\n    if(getOptions().recordHistory){\n        location.hash = url;\n    }",
    "comment": "* Sets the URL hash.",
    "language": "javascript",
    "repo": "alvarotrigo/fullPage.js",
    "file_path": "src/js/anchors/setPageStatus.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function generateGrayCodes(n) {\n  if (n <= 0) {\n    return [0]\n  }",
    "comment": "* Generates a Gray code sequence for the given number of bits.\n * @param {number} n - The number of bits in the Gray code sequence.\n * @returns {number[]} - An array of Gray codes in binary format.\n * @description\n * Gray codes are binary sequences in which two successive values differ in only one bit.\n * This function generates a Gray code sequence of length 2^n for the given number of bits.\n *\n * The algorithm follows these steps:\n *\n * 1. Initialize an array `grayCodes` to store the Gray codes. Start with [0, 1] for n = 1.\n * 2. Iterate from 1 to n:\n *    a. Calculate `highestBit` as 2^i, where `i` is the current iteration index.\n *    b. Iterate in reverse order through the existing Gray codes:\n *       - For each Gray code `code`, add `highestBit | code` to `grayCodes`.\n *       - This operation flips a single bit in each existing code, creating new codes.\n * 3. Return the `grayCodes` array containing the Gray codes in decimal representation.\n *\n *resources: [GFG](https://www.geeksforgeeks.org/generate-n-bit-gray-codes/)\n * @example\n * const n = 3;\n * const grayCodes = generateGrayCodes(n);\n * // grayCodes will be [0, 1, 3, 2, 6, 7, 5, 4] for n=3.",
    "language": "javascript",
    "repo": "TheAlgorithms/JavaScript",
    "file_path": "Bit-Manipulation/GrayCodes.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function autoInject(tasks, callback) {\n    var newTasks = {}",
    "comment": "* A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent\n * tasks are specified as parameters to the function, after the usual callback\n * parameter, with the parameter names matching the names of the tasks it\n * depends on. This can provide even more readable task graphs which can be\n * easier to maintain.\n *\n * If a final callback is specified, the task results are similarly injected,\n * specified as named parameters after the initial error parameter.\n *\n * The autoInject function is purely syntactic sugar and its semantics are\n * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.\n *\n * @name autoInject\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.auto]{@link module:ControlFlow.auto}\n * @category Control Flow\n * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of\n * the form 'func([dependencies...], callback). The object's key of a property\n * serves as the name of the task defined by that property, i.e. can be used\n * when specifying requirements for other tasks.\n * * The `callback` parameter is a `callback(err, result)` which must be called\n *   when finished, passing an `error` (which can be `null`) and the result of\n *   the function's execution. The remaining parameters name other tasks on\n *   which the task is dependent, and the results from those tasks are the\n *   arguments of those parameters.\n * @param {Function} [callback] - An optional callback which is called when all\n * the tasks have been completed. It receives the `err` argument if any `tasks`\n * pass an error to their callback, and a `results` object with any completed\n * task results, similar to `auto`.\n * @returns {Promise} a promise, if no callback is passed\n * @example\n *\n * //  The example from `auto` can be rewritten as follows:\n * async.autoInject({\n *     get_data: function(callback) {\n *         // async code to get some data\n *         callback(null, 'data', 'converted to array');\n *     },\n *     make_folder: function(callback) {\n *         // async code to create a directory to store a file in\n *         // this is run at the same time as getting the data\n *         callback(null, 'folder');\n *     },\n *     write_file: function(get_data, make_folder, callback) {\n *         // once there is some data and the directory exists,\n *         // write the data to a file in the directory\n *         callback(null, 'filename');\n *     },\n *     email_link: function(write_file, callback) {\n *         // once the file is written let's email a link to it...\n *         // write_file contains the filename returned by write_file.\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });\n *\n * // If you are using a JS minifier that mangles parameter names, `autoInject`\n * // will not work with plain functions, since the parameter names will be\n * // collapsed to a single letter identifier.  To work around this, you can\n * // explicitly specify the names of the parameters your task function needs\n * // in an array, similar to Angular.js dependency injection.\n *\n * // This still has an advantage over plain `auto`, since the results a task\n * // depends on are still spread into arguments.\n * async.autoInject({\n *     //...\n *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {\n *         callback(null, 'filename');\n *     }],\n *     email_link: ['write_file', function(write_file, callback) {\n *         callback(null, {'file':write_file, 'email':'user@example.com'});\n *     }]\n *     //...\n * }, function(err, results) {\n *     console.log('err = ', err);\n *     console.log('email_link = ', results.email_link);\n * });",
    "language": "javascript",
    "repo": "caolan/async",
    "file_path": "lib/autoInject.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function cargo(worker, payload) {\n    return queue(worker, 1, payload);\n}",
    "comment": "* Creates a `cargo` object with the specified payload. Tasks added to the\n * cargo will be processed altogether (up to the `payload` limit). If the\n * `worker` is in progress, the task is queued until it becomes available. Once\n * the `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, cargo passes an array of tasks to a single worker, repeating\n * when the worker is finished.\n *\n * @name cargo\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.QueueObject} A cargo object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargo and inner queue.\n * @example\n *\n * // create a cargo object with payload 2\n * var cargo = async.cargo(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2);\n *\n * // add some items\n * cargo.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargo.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * await cargo.push({name: 'baz'});\n * console.log('finished processing baz');",
    "language": "javascript",
    "repo": "caolan/async",
    "file_path": "lib/cargo.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function cargo(worker, concurrency, payload) {\n    return queue(worker, concurrency, payload);\n}",
    "comment": "* Creates a `cargoQueue` object with the specified payload. Tasks added to the\n * cargoQueue will be processed together (up to the `payload` limit) in `concurrency` parallel workers.\n * If the all `workers` are in progress, the task is queued until one becomes available. Once\n * a `worker` has completed some tasks, each callback of those tasks is\n * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)\n * for how `cargo` and `queue` work.\n *\n * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers\n * at a time, and [`cargo`]{@link module:ControlFlow.cargo} passes an array of tasks to a single worker,\n * the cargoQueue passes an array of tasks to multiple parallel workers.\n *\n * @name cargoQueue\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @see [async.queue]{@link module:ControlFlow.queue}\n * @see [async.cargo]{@link module:ControlFLow.cargo}\n * @category Control Flow\n * @param {AsyncFunction} worker - An asynchronous function for processing an array\n * of queued tasks. Invoked with `(tasks, callback)`.\n * @param {number} [concurrency=1] - An `integer` for determining how many\n * `worker` functions should be run in parallel.  If omitted, the concurrency\n * defaults to `1`.  If the concurrency is `0`, an error is thrown.\n * @param {number} [payload=Infinity] - An optional `integer` for determining\n * how many tasks should be processed per round; if omitted, the default is\n * unlimited.\n * @returns {module:ControlFlow.QueueObject} A cargoQueue object to manage the tasks. Callbacks can\n * attached as certain properties to listen for specific events during the\n * lifecycle of the cargoQueue and inner queue.\n * @example\n *\n * // create a cargoQueue object with payload 2 and concurrency 2\n * var cargoQueue = async.cargoQueue(function(tasks, callback) {\n *     for (var i=0; i<tasks.length; i++) {\n *         console.log('hello ' + tasks[i].name);\n *     }\n *     callback();\n * }, 2, 2);\n *\n * // add some items\n * cargoQueue.push({name: 'foo'}, function(err) {\n *     console.log('finished processing foo');\n * });\n * cargoQueue.push({name: 'bar'}, function(err) {\n *     console.log('finished processing bar');\n * });\n * cargoQueue.push({name: 'baz'}, function(err) {\n *     console.log('finished processing baz');\n * });\n * cargoQueue.push({name: 'boo'}, function(err) {\n *     console.log('finished processing boo');\n * });",
    "language": "javascript",
    "repo": "caolan/async",
    "file_path": "lib/cargoQueue.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function compose(...args) {\n    return seq(...args.reverse());\n}",
    "comment": "* Creates a function which is a composition of the passed asynchronous\n * functions. Each function consumes the return value of the function that\n * follows. Composing functions `f()`, `g()`, and `h()` would produce the result\n * of `f(g(h()))`, only this version uses callbacks to obtain the return values.\n *\n * If the last argument to the composed function is not a function, a promise\n * is returned when you call it.\n *\n * Each function is executed with the `this` binding of the composed function.\n *\n * @name compose\n * @static\n * @memberOf module:ControlFlow\n * @method\n * @category Control Flow\n * @param {...AsyncFunction} functions - the asynchronous functions to compose\n * @returns {Function} an asynchronous function that is the composed\n * asynchronous `functions`\n * @example\n *\n * function add1(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n + 1);\n *     }, 10);\n * }\n *\n * function mul3(n, callback) {\n *     setTimeout(function () {\n *         callback(null, n * 3);\n *     }, 10);\n * }\n *\n * var add1mul3 = async.compose(mul3, add1);\n * add1mul3(4, function (err, result) {\n *     // result now equals 15\n * });",
    "language": "javascript",
    "repo": "caolan/async",
    "file_path": "lib/compose.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function concat(coll, iteratee, callback) {\n    return concatLimit(coll, Infinity, iteratee, callback)\n}",
    "comment": "* Applies `iteratee` to each item in `coll`, concatenating the results. Returns\n * the concatenated list. The `iteratee`s are called in parallel, and the\n * results are concatenated as they return. The results array will be returned in\n * the original order of `coll` passed to the `iteratee` function.\n *\n * @name concat\n * @static\n * @memberOf module:Collections\n * @method\n * @category Collection\n * @alias flatMap\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,\n * which should use an array as its result. Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @returns A Promise, if no callback is passed\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n * // dir4 does not exist\n *\n * let directoryList = ['dir1','dir2','dir3'];\n * let withMissingDirectoryList = ['dir1','dir2','dir3', 'dir4'];\n *\n * // Using callbacks\n * async.concat(directoryList, fs.readdir, function(err, results) {\n *    if (err) {\n *        console.log(err);\n *    } else {\n *        console.log(results);\n *        // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n *    }\n * });\n *\n * // Error Handling\n * async.concat(withMissingDirectoryList, fs.readdir, function(err, results) {\n *    if (err) {\n *        console.log(err);\n *        // [ Error: ENOENT: no such file or directory ]\n *        // since dir4 does not exist\n *    } else {\n *        console.log(results);\n *    }\n * });\n *\n * // Using Promises\n * async.concat(directoryList, fs.readdir)\n * .then(results => {\n *     console.log(results);\n *     // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n * }).catch(err => {\n *      console.log(err);\n * });\n *\n * // Error Handling\n * async.concat(withMissingDirectoryList, fs.readdir)\n * .then(results => {\n *     console.log(results);\n * }).catch(err => {\n *     console.log(err);\n *     // [ Error: ENOENT: no such file or directory ]\n *     // since dir4 does not exist\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let results = await async.concat(directoryList, fs.readdir);\n *         console.log(results);\n *         // [ 'file1.txt', 'file2.txt', 'file3.txt', 'file4.txt', file5.txt ]\n *     } catch (err) {\n *         console.log(err);\n *     }\n * }\n *\n * // Error Handling\n * async () => {\n *     try {\n *         let results = await async.concat(withMissingDirectoryList, fs.readdir);\n *         console.log(results);\n *     } catch (err) {\n *         console.log(err);\n *         // [ Error: ENOENT: no such file or directory ]\n *         // since dir4 does not exist\n *     }\n * }\n *",
    "language": "javascript",
    "repo": "caolan/async",
    "file_path": "lib/concat.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function concatSeries(coll, iteratee, callback) {\n    return concatLimit(coll, 1, iteratee, callback)\n}",
    "comment": "* The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.\n *\n * @name concatSeries\n * @static\n * @memberOf module:Collections\n * @method\n * @see [async.concat]{@link module:Collections.concat}\n * @category Collection\n * @alias flatMapSeries\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.\n * The iteratee should complete with an array an array of results.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called after all the\n * `iteratee` functions have finished, or an error occurs. Results is an array\n * containing the concatenated results of the `iteratee` function. Invoked with\n * (err, results).\n * @returns A Promise, if no callback is passed",
    "language": "javascript",
    "repo": "caolan/async",
    "file_path": "lib/concatSeries.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function detect(coll, iteratee, callback) {\n    return createTester(bool => bool, (res, item) => item)(eachOf, coll, iteratee, callback)\n}",
    "comment": "* Returns the first value in `coll` that passes an async truth test. The\n * `iteratee` is applied in parallel, meaning the first iteratee to return\n * `true` will fire the detect `callback` with that result. That means the\n * result might not be the first item in the original `coll` (in terms of order)\n * that passes the test.\n\n * If order within the original `coll` is important, then look at\n * [`detectSeries`]{@link module:Collections.detectSeries}.\n *\n * @name detect\n * @static\n * @memberOf module:Collections\n * @method\n * @alias find\n * @category Collections\n * @param {Array|Iterable|AsyncIterable|Object} coll - A collection to iterate over.\n * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.\n * The iteratee must complete with a boolean value as its result.\n * Invoked with (item, callback).\n * @param {Function} [callback] - A callback which is called as soon as any\n * iteratee returns `true`, or after all the `iteratee` functions have finished.\n * Result will be the first item in the array that passes the truth test\n * (iteratee) or the value `undefined` if none passed. Invoked with\n * (err, result).\n * @returns {Promise} a promise, if a callback is omitted\n * @example\n *\n * // dir1 is a directory that contains file1.txt, file2.txt\n * // dir2 is a directory that contains file3.txt, file4.txt\n * // dir3 is a directory that contains file5.txt\n *\n * // asynchronous function that checks if a file exists\n * function fileExists(file, callback) {\n *    fs.access(file, fs.constants.F_OK, (err) => {\n *        callback(null, !err);\n *    });\n * }\n *\n * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists,\n *    function(err, result) {\n *        console.log(result);\n *        // dir1/file1.txt\n *        // result now equals the first file in the list that exists\n *    }\n *);\n *\n * // Using Promises\n * async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists)\n * .then(result => {\n *     console.log(result);\n *     // dir1/file1.txt\n *     // result now equals the first file in the list that exists\n * }).catch(err => {\n *     console.log(err);\n * });\n *\n * // Using async/await\n * async () => {\n *     try {\n *         let result = await async.detect(['file3.txt','file2.txt','dir1/file1.txt'], fileExists);\n *         console.log(result);\n *         // dir1/file1.txt\n *         // result now equals the file in the list that exists\n *     }\n *     catch (err) {\n *         console.log(err);\n *     }\n * }\n *",
    "language": "javascript",
    "repo": "caolan/async",
    "file_path": "lib/detect.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function listLanguages() {\n    return Object.keys(languages);\n  }",
    "comment": "* @returns {string[]} List of language internal names",
    "language": "javascript",
    "repo": "highlightjs/highlight.js",
    "file_path": "src/highlight.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "class ExceptionHandler {\n  /**\n   * TODO: add contructor description\n   * @param {!Logger}",
    "comment": "* Object for handling uncaughtException events.\n * @type {ExceptionHandler}",
    "language": "javascript",
    "repo": "winstonjs/winston",
    "file_path": "lib/winston/exception-handler.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "class RejectionHandler {\n  /**\n   * TODO: add contructor description\n   * @param {!Logger}",
    "comment": "* Object for handling unhandledRejection events.\n * @type {RejectionHandler}",
    "language": "javascript",
    "repo": "winstonjs/winston",
    "file_path": "lib/winston/rejection-handler.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function noop() {}",
    "comment": "* Simple no-op function.\n * @returns {undefined}",
    "language": "javascript",
    "repo": "winstonjs/winston",
    "file_path": "lib/winston/tail-file.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function fileSize({ module, decimals = 1, filesizes }) {\n    const filesize = (filesizes[module] / 1024);\n    return filesize.toFixed(decimals) + 'KB';\n}",
    "comment": "* Calculates filesize for a given module",
    "language": "javascript",
    "repo": "pure-css/pure",
    "file_path": "site/lib/utils.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function filePercent({ modules, module, filesizes }) {\n    const total = modules.reduce((size, m) => {\n        return size + filesizes[m];\n    }",
    "comment": "* Calculates the module percentage size against all modules",
    "language": "javascript",
    "repo": "pure-css/pure",
    "file_path": "site/lib/utils.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function authenticate(passport, name, options, callback) {\n  if (typeof options == 'function') {\n    callback = options;\n    options = {}",
    "comment": "* Authenticates requests.\n *\n * Applies the `name`ed strategy (or strategies) to the incoming request, in\n * order to authenticate the request.  If authentication is successful, the user\n * will be logged in and populated at `req.user` and a session will be\n * established by default.  If authentication fails, an unauthorized response\n * will be sent.\n *\n * Options:\n *   - `session`          Save login state in session, defaults to _true_\n *   - `successRedirect`  After successful login, redirect to given URL\n *   - `successMessage`   True to store success message in\n *                        req.session.messages, or a string to use as override\n *                        message for success.\n *   - `successFlash`     True to flash success messages or a string to use as a flash\n *                        message for success (overrides any from the strategy itself).\n *   - `failureRedirect`  After failed login, redirect to given URL\n *   - `failureMessage`   True to store failure message in\n *                        req.session.messages, or a string to use as override\n *                        message for failure.\n *   - `failureFlash`     True to flash failure messages or a string to use as a flash\n *                        message for failures (overrides any from the strategy itself).\n *   - `assignProperty`   Assign the object provided by the verify callback to given property\n *\n * An optional `callback` can be supplied to allow the application to override\n * the default manner in which authentication attempts are handled.  The\n * callback has the following signature, where `user` will be set to the\n * authenticated user on a successful authentication attempt, or `false`\n * otherwise.  An optional `info` argument will be passed, containing additional\n * details provided by the strategy's verify callback - this could be information about\n * a successful authentication or a challenge message for a failed authentication.\n * An optional `status` argument will be passed when authentication fails - this could\n * be a HTTP response code for a remote authentication failure or similar.\n *\n *     app.get('/protected', function(req, res, next) {\n *       passport.authenticate('local', function(err, user, info, status) {\n *         if (err) { return next(err) }\n *         if (!user) { return res.redirect('/signin') }\n *         res.redirect('/account');\n *       })(req, res, next);\n *     });\n *\n * Note that if a callback is supplied, it becomes the application's\n * responsibility to log-in the user, establish a session, and otherwise perform\n * the desired operations.\n *\n * Examples:\n *\n *     passport.authenticate('local', { successRedirect: '/', failureRedirect: '/login' });\n *\n *     passport.authenticate('basic', { session: false });\n *\n *     passport.authenticate('twitter');\n *\n * @param {Strategy|String|Array} name\n * @param {Object} options\n * @param {Function} callback\n * @return {Function}\n * @api public",
    "language": "javascript",
    "repo": "jaredhanson/passport",
    "file_path": "lib/middleware/authenticate.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  },
  {
    "code": "function initialize(passport, options) {\n  options = options || {}",
    "comment": "* Passport initialization.\n *\n * Intializes Passport for incoming requests, allowing authentication strategies\n * to be applied.\n *\n * If sessions are being utilized, applications must set up Passport with\n * functions to serialize a user into and out of a session.  For example, a\n * common pattern is to serialize just the user ID into the session (due to the\n * fact that it is desirable to store the minimum amount of data in a session).\n * When a subsequent request arrives for the session, the full User object can\n * be loaded from the database by ID.\n *\n * Note that additional middleware is required to persist login state, so we\n * must use the `connect.session()` middleware _before_ `passport.initialize()`.\n *\n * If sessions are being used, this middleware must be in use by the\n * Connect/Express application for Passport to operate.  If the application is\n * entirely stateless (not using sessions), this middleware is not necessary,\n * but its use will not have any adverse impact.\n *\n * Examples:\n *\n *     app.use(connect.cookieParser());\n *     app.use(connect.session({ secret: 'keyboard cat' }));\n *     app.use(passport.initialize());\n *     app.use(passport.session());\n *\n *     passport.serializeUser(function(user, done) {\n *       done(null, user.id);\n *     });\n *\n *     passport.deserializeUser(function(id, done) {\n *       User.findById(id, function (err, user) {\n *         done(err, user);\n *       });\n *     });\n *\n * @return {Function}\n * @api public",
    "language": "javascript",
    "repo": "jaredhanson/passport",
    "file_path": "lib/middleware/initialize.js",
    "quality_score": 0.1,
    "comment_type": "jsdoc"
  }
]